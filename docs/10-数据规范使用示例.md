# Pipeline Builder - 数据规范使用示例

> 如何在前端代码中使用Pipeline数据规范
>
> 版本：v1.0
> 创建时间：2025年

## 目录

1. [类型导入与使用](#1-类型导入与使用)
2. [创建Pipeline](#2-创建pipeline)
3. [操作节点](#3-操作节点)
4. [Graph与Pipeline转换](#4-graph与pipeline转换)
5. [API调用示例](#5-api调用示例)
6. [数据验证](#6-数据验证)
7. [WebSocket实时通信](#7-websocket实时通信)

---

## 1. 类型导入与使用

### 1.1 基础导入

```typescript
// 导入类型定义
import type {
  Pipeline,
  Node,
  Edge,
  DatasetNodeConfig,
  SqlTransformNodeConfig,
  ValidationResult
} from '@/types/pipeline'

// 导入工具函数
import {
  graphToPipeline,
  pipelineToGraph,
  createNode,
  createEdge,
  hasCycle,
  validateEdgeConnection
} from '@/utils/pipelineTransform'
```

### 1.2 在组件中使用类型

```vue
<script setup lang="ts">
import { ref, computed } from 'vue'
import type { Pipeline, Node } from '@/types/pipeline'
import { usePipelineStore } from '@/stores/pipeline'

// 使用类型约束
const currentPipeline = ref<Pipeline | null>(null)
const selectedNode = ref<Node | null>(null)

// 使用类型守卫
function handleNodeSelect(node: Node) {
  if (isDatasetNode(node)) {
    // TypeScript现在知道node.config是DatasetNodeConfig类型
    console.log('Dataset ID:', node.config.datasetId)
  }
}

// 类型安全的计算属性
const nodeCount = computed((): number => {
  return currentPipeline.value?.graph.nodes.length || 0
})
</script>
```

---

## 2. 创建Pipeline

### 2.1 从零创建Pipeline

```typescript
import { v4 as uuidv4 } from 'uuid'
import type { Pipeline, CreatePipelineRequest } from '@/types/pipeline'
import { createNode, createEdge } from '@/utils/pipelineTransform'

/**
 * 创建一个新的Pipeline
 */
function createNewPipeline(name: string): CreatePipelineRequest {
  // 创建数据源节点
  const datasetNode = createNode('dataset', { x: 100, y: 100 }, {
    datasetId: 'dataset-123',
    datasetName: 'user_events',
    source: { type: 'foundry' },
    snapshot: { enabled: true, type: 'latest' }
  })

  // 创建SQL转换节点
  const sqlNode = createNode('sql-transform', { x: 400, y: 100 }, {
    sql: 'SELECT * FROM events WHERE status = "active"',
    dialect: 'standard',
    inputAliases: { [datasetNode.ports.output[0].id]: 'events' }
  })

  // 创建输出节点
  const outputNode = createNode('dataset-output', { x: 700, y: 100 }, {
    datasetId: 'dataset-456',
    datasetName: 'active_users',
    destination: { type: 'foundry' },
    writeMode: 'overwrite',
    createIfNotExists: true
  })

  // 创建连接
  const edge1 = createEdge(
    datasetNode.id,
    datasetNode.ports.output[0].id,
    sqlNode.id,
    sqlNode.ports.input[0].id
  )

  const edge2 = createEdge(
    sqlNode.id,
    sqlNode.ports.output[0].id,
    outputNode.id,
    outputNode.ports.input[0].id
  )

  // 组装Pipeline
  return {
    name,
    description: 'Process user events and filter active users',
    version: '1.0.0',

    metadata: {
      category: 'ETL',
      tags: ['user-data', 'production'],
      owner: 'current-user-id',
      visibility: 'team',
      status: 'draft'
    },

    graph: {
      nodes: [datasetNode, sqlNode, outputNode],
      edges: [edge1, edge2]
    },

    configuration: {
      execution: {
        mode: 'sequential',
        timeout: 3600,
        retryPolicy: {
          maxRetries: 3,
          retryDelay: 60,
          exponentialBackoff: true
        }
      },
      schedule: {
        enabled: true,
        cron: '0 2 * * *',
        timezone: 'Asia/Shanghai'
      }
    }
  }
}

// 使用示例
const newPipeline = createNewPipeline('User Analytics Pipeline')
console.log(newPipeline)
```

### 2.2 使用Pinia Store创建

```typescript
// stores/pipeline.ts
import { defineStore } from 'pinia'
import type { Pipeline, CreatePipelineRequest } from '@/types/pipeline'
import { pipelineApi } from '@/api/pipeline'

export const usePipelineStore = defineStore('pipeline', () => {
  const currentPipeline = ref<Pipeline | null>(null)

  /**
   * 创建新Pipeline
   */
  async function createPipeline(data: CreatePipelineRequest): Promise<Pipeline> {
    try {
      const response = await pipelineApi.create(data)
      currentPipeline.value = response.data
      return response.data
    } catch (error) {
      console.error('Failed to create pipeline:', error)
      throw error
    }
  }

  return {
    currentPipeline,
    createPipeline
  }
})

// 在组件中使用
import { usePipelineStore } from '@/stores/pipeline'

const pipelineStore = usePipelineStore()

async function handleCreate() {
  const pipelineData = createNewPipeline('My Pipeline')
  const pipeline = await pipelineStore.createPipeline(pipelineData)
  console.log('Created pipeline:', pipeline.id)
}
```

---

## 3. 操作节点

### 3.1 添加节点

```typescript
import type { Node } from '@/types/pipeline'
import { createNode } from '@/utils/pipelineTransform'

/**
 * 在指定位置添加节点
 */
function addNodeToPipeline(
  pipeline: Pipeline,
  nodeType: Node['type'],
  position: { x: number; y: number }
): Pipeline {
  const newNode = createNode(nodeType, position)

  return {
    ...pipeline,
    graph: {
      ...pipeline.graph,
      nodes: [...pipeline.graph.nodes, newNode]
    },
    updatedAt: new Date().toISOString()
  }
}

// 使用示例
const updatedPipeline = addNodeToPipeline(
  currentPipeline,
  'filter',
  { x: 300, y: 200 }
)
```

### 3.2 更新节点配置

```typescript
import type { Node, SqlTransformNodeConfig } from '@/types/pipeline'

/**
 * 更新节点配置
 */
function updateNodeConfig<T extends NodeConfig>(
  pipeline: Pipeline,
  nodeId: string,
  config: Partial<T>
): Pipeline {
  return {
    ...pipeline,
    graph: {
      ...pipeline.graph,
      nodes: pipeline.graph.nodes.map(node =>
        node.id === nodeId
          ? {
              ...node,
              config: { ...node.config, ...config },
              updatedAt: new Date().toISOString()
            }
          : node
      )
    },
    updatedAt: new Date().toISOString()
  }
}

// 使用示例：更新SQL节点的SQL语句
const updatedPipeline = updateNodeConfig<SqlTransformNodeConfig>(
  currentPipeline,
  'node-123',
  {
    sql: 'SELECT user_id, COUNT(*) as event_count FROM events GROUP BY user_id',
    outputSchema: {
      type: 'object',
      properties: {
        user_id: { name: 'user_id', type: 'string' },
        event_count: { name: 'event_count', type: 'number' }
      }
    }
  }
)
```

### 3.3 删除节点

```typescript
/**
 * 删除节点（同时删除相关的边）
 */
function deleteNode(pipeline: Pipeline, nodeId: string): Pipeline {
  return {
    ...pipeline,
    graph: {
      ...pipeline.graph,
      nodes: pipeline.graph.nodes.filter(n => n.id !== nodeId),
      edges: pipeline.graph.edges.filter(
        e => e.source.nodeId !== nodeId && e.target.nodeId !== nodeId
      )
    },
    updatedAt: new Date().toISOString()
  }
}
```

### 3.4 类型安全的节点操作

```typescript
import {
  isDatasetNode,
  isSqlTransformNode,
  isPythonTransformNode
} from '@/types/pipeline'

/**
 * 根据节点类型执行不同操作
 */
function handleNodeConfiguration(node: Node) {
  if (isDatasetNode(node)) {
    // TypeScript知道这里node.config是DatasetNodeConfig类型
    console.log('Dataset:', node.config.datasetName)
    console.log('Snapshot:', node.config.snapshot.type)
  } else if (isSqlTransformNode(node)) {
    // TypeScript知道这里node.config是SqlTransformNodeConfig类型
    console.log('SQL:', node.config.sql)
    console.log('Dialect:', node.config.dialect)
  } else if (isPythonTransformNode(node)) {
    // TypeScript知道这里node.config是PythonTransformNodeConfig类型
    console.log('Python version:', node.config.runtime.version)
    console.log('Requirements:', node.config.runtime.requirements)
  }
}
```

---

## 4. Graph与Pipeline转换

### 4.1 从Graph保存到Pipeline

```vue
<script setup lang="ts">
import { ref } from 'vue'
import type { Graph } from '@antv/x6'
import { graphToPipeline } from '@/utils/pipelineTransform'
import { usePipelineStore } from '@/stores/pipeline'

const graphRef = ref<Graph>()
const pipelineStore = usePipelineStore()

/**
 * 保存Pipeline
 */
async function handleSave() {
  if (!graphRef.value) return

  // 将Graph数据转换为Pipeline JSON
  const pipelineData = graphToPipeline(
    graphRef.value,
    pipelineStore.currentPipeline
  )

  // 调用API保存
  if (pipelineStore.currentPipeline?.id) {
    await pipelineApi.update(pipelineStore.currentPipeline.id, pipelineData)
  } else {
    await pipelineApi.create(pipelineData)
  }
}
</script>
```

### 4.2 从Pipeline加载到Graph

```vue
<script setup lang="ts">
import { ref, onMounted } from 'vue'
import type { Graph } from '@antv/x6'
import { pipelineToGraph } from '@/utils/pipelineTransform'
import { usePipelineStore } from '@/stores/pipeline'

const graphRef = ref<Graph>()
const pipelineStore = usePipelineStore()

/**
 * 加载Pipeline
 */
onMounted(async () => {
  // 获取Pipeline数据
  await pipelineStore.loadPipeline(route.params.id)

  // 加载到Graph
  if (graphRef.value && pipelineStore.currentPipeline) {
    pipelineToGraph(pipelineStore.currentPipeline, graphRef.value)
  }
})
</script>
```

---

## 5. API调用示例

### 5.1 API模块定义

```typescript
// api/pipeline.ts
import { request } from '@/utils/request'
import type {
  Pipeline,
  CreatePipelineRequest,
  UpdatePipelineRequest,
  SuccessResponse,
  PaginatedResponse,
  QueryPipelinesParams
} from '@/types/pipeline'

/**
 * Pipeline API模块
 */
export const pipelineApi = {
  /**
   * 创建Pipeline
   */
  async create(data: CreatePipelineRequest): Promise<SuccessResponse<Pipeline>> {
    return request.post('/api/v1/pipelines', data)
  },

  /**
   * 获取Pipeline列表
   */
  async list(params: QueryPipelinesParams): Promise<PaginatedResponse<Pipeline>> {
    return request.get('/api/v1/pipelines', { params })
  },

  /**
   * 获取单个Pipeline
   */
  async getById(id: string): Promise<SuccessResponse<Pipeline>> {
    return request.get(`/api/v1/pipelines/${id}`)
  },

  /**
   * 更新Pipeline
   */
  async update(
    id: string,
    data: UpdatePipelineRequest
  ): Promise<SuccessResponse<Pipeline>> {
    return request.put(`/api/v1/pipelines/${id}`, data)
  },

  /**
   * 删除Pipeline
   */
  async delete(id: string): Promise<void> {
    return request.delete(`/api/v1/pipelines/${id}`)
  },

  /**
   * 运行Pipeline
   */
  async execute(
    id: string,
    params?: { parameters?: Record<string, any> }
  ): Promise<SuccessResponse<{ executionId: string }>> {
    return request.post(`/api/v1/pipelines/${id}/execute`, params)
  }
}
```

### 5.2 在组件中使用API

```vue
<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { useRoute } from 'vue-router'
import type { Pipeline } from '@/types/pipeline'
import { pipelineApi } from '@/api/pipeline'
import { message } from 'ant-design-vue'

const route = useRoute()
const pipeline = ref<Pipeline | null>(null)
const loading = ref(false)

/**
 * 加载Pipeline数据
 */
async function loadPipeline() {
  loading.value = true
  try {
    const response = await pipelineApi.getById(route.params.id as string)
    pipeline.value = response.data
  } catch (error) {
    message.error('Failed to load pipeline')
    console.error(error)
  } finally {
    loading.value = false
  }
}

/**
 * 保存Pipeline
 */
async function savePipeline() {
  if (!pipeline.value) return

  loading.value = true
  try {
    await pipelineApi.update(pipeline.value.id, {
      name: pipeline.value.name,
      description: pipeline.value.description,
      graph: pipeline.value.graph
    })
    message.success('Pipeline saved successfully')
  } catch (error) {
    message.error('Failed to save pipeline')
    console.error(error)
  } finally {
    loading.value = false
  }
}

/**
 * 运行Pipeline
 */
async function runPipeline() {
  if (!pipeline.value) return

  try {
    const response = await pipelineApi.execute(pipeline.value.id)
    message.success(`Pipeline execution started: ${response.data.executionId}`)

    // 导航到执行详情页
    router.push(`/executions/${response.data.executionId}`)
  } catch (error) {
    message.error('Failed to start pipeline execution')
    console.error(error)
  }
}

onMounted(() => {
  loadPipeline()
})
</script>
```

---

## 6. 数据验证

### 6.1 Pipeline验证

```typescript
import { hasCycle, validateEdgeConnection, topologicalSort } from '@/utils/pipelineTransform'
import type { Pipeline, ValidationResult } from '@/types/pipeline'

/**
 * 验证Pipeline是否合法
 */
function validatePipeline(pipeline: Pipeline): ValidationResult {
  const errors: ValidationError[] = []
  const warnings: ValidationWarning[] = []

  // 1. 检查是否有环
  if (hasCycle(pipeline.graph)) {
    errors.push({
      field: 'graph',
      code: 'CYCLE_DETECTED',
      message: 'Pipeline graph contains cycles. DAG (Directed Acyclic Graph) is required.'
    })
  }

  // 2. 检查节点数量
  if (pipeline.graph.nodes.length === 0) {
    errors.push({
      field: 'graph.nodes',
      code: 'NO_NODES',
      message: 'Pipeline must contain at least one node'
    })
  }

  // 3. 检查每条边的连接是否有效
  pipeline.graph.edges.forEach((edge, index) => {
    const validation = validateEdgeConnection(edge, pipeline.graph.nodes)
    if (!validation.valid) {
      errors.push({
        field: `graph.edges[${index}]`,
        code: 'INVALID_EDGE',
        message: validation.error || 'Invalid edge connection'
      })
    }
  })

  // 4. 检查必需端口是否连接
  pipeline.graph.nodes.forEach((node, index) => {
    node.ports.input.forEach((port) => {
      if (port.required) {
        const hasConnection = pipeline.graph.edges.some(
          (edge) => edge.target.nodeId === node.id && edge.target.portId === port.id
        )

        if (!hasConnection) {
          warnings.push({
            field: `graph.nodes[${index}].ports.input`,
            code: 'REQUIRED_PORT_NOT_CONNECTED',
            message: `Required input port '${port.label || port.id}' is not connected`,
            suggestion: `Connect a node to the '${port.label || port.id}' input port`
          })
        }
      }
    })
  })

  // 5. 检查SQL语法（针对SQL节点）
  pipeline.graph.nodes.forEach((node, index) => {
    if (isSqlTransformNode(node)) {
      if (!node.config.sql || node.config.sql.trim() === '') {
        errors.push({
          field: `graph.nodes[${index}].config.sql`,
          code: 'EMPTY_SQL',
          message: 'SQL statement cannot be empty'
        })
      }

      // 简单的SQL关键词检查
      const sql = node.config.sql.toLowerCase()
      if (!sql.includes('select')) {
        warnings.push({
          field: `graph.nodes[${index}].config.sql`,
          code: 'INVALID_SQL_SYNTAX',
          message: 'SQL statement should contain SELECT keyword',
          suggestion: 'Check SQL syntax'
        })
      }
    }
  })

  return {
    valid: errors.length === 0,
    errors,
    warnings
  }
}

// 使用示例
const validation = validatePipeline(currentPipeline)

if (!validation.valid) {
  console.error('Pipeline validation failed:', validation.errors)
  message.error('Pipeline validation failed')

  // 显示错误详情
  validation.errors.forEach((error) => {
    console.error(`[${error.code}] ${error.field}: ${error.message}`)
  })
}

if (validation.warnings && validation.warnings.length > 0) {
  console.warn('Pipeline has warnings:', validation.warnings)
}
```

### 6.2 实时验证

```vue
<script setup lang="ts">
import { ref, watch } from 'vue'
import type { Pipeline, ValidationResult } from '@/types/pipeline'
import { validatePipeline } from '@/utils/validation'

const pipeline = ref<Pipeline | null>(null)
const validation = ref<ValidationResult>({
  valid: true,
  errors: [],
  warnings: []
})

// 监听Pipeline变化，实时验证
watch(
  () => pipeline.value,
  (newPipeline) => {
    if (newPipeline) {
      validation.value = validatePipeline(newPipeline)
    }
  },
  { deep: true }
)

// 在保存前验证
async function handleSave() {
  if (!validation.value.valid) {
    message.error('Please fix validation errors before saving')
    return
  }

  // 执行保存
  await savePipeline()
}
</script>

<template>
  <div>
    <!-- 验证错误提示 -->
    <a-alert
      v-if="!validation.valid"
      type="error"
      message="Validation Errors"
      :description="`Found ${validation.errors.length} error(s)`"
      show-icon
      closable
    >
      <template #description>
        <ul>
          <li v-for="error in validation.errors" :key="error.code">
            {{ error.message }}
          </li>
        </ul>
      </template>
    </a-alert>

    <!-- 验证警告 -->
    <a-alert
      v-if="validation.warnings && validation.warnings.length > 0"
      type="warning"
      message="Validation Warnings"
      show-icon
      closable
      style="margin-top: 16px"
    >
      <template #description>
        <ul>
          <li v-for="warning in validation.warnings" :key="warning.code">
            {{ warning.message }}
            <span v-if="warning.suggestion" style="color: #666">
              ({{ warning.suggestion }})
            </span>
          </li>
        </ul>
      </template>
    </a-alert>
  </div>
</template>
```

---

## 7. WebSocket实时通信

### 7.1 Composable封装

```typescript
// composables/useExecution.ts
import { ref, onMounted, onUnmounted } from 'vue'
import { io, Socket } from 'socket.io-client'
import type {
  Execution,
  ExecutionLog,
  ExecutionMetrics,
  WebSocketEvents
} from '@/types/pipeline'
import { useUserStore } from '@/stores/user'

export function useExecution(executionId: string) {
  const socket = ref<Socket>()
  const execution = ref<Execution | null>(null)
  const logs = ref<ExecutionLog[]>([])
  const metrics = ref<ExecutionMetrics[]>([])

  const userStore = useUserStore()

  /**
   * 连接WebSocket
   */
  function connect() {
    socket.value = io('wss://api.example.com/executions', {
      auth: {
        token: userStore.token
      }
    })

    // 连接成功
    socket.value.on('connect', () => {
      console.log('WebSocket connected')

      // 订阅执行
      socket.value?.emit('subscribe', { executionId })
    })

    // 执行状态更新
    socket.value.on('execution:status', (data: WebSocketEvents['execution:status']) => {
      console.log('Execution status:', data.status, data.progress)

      if (execution.value) {
        execution.value.status = data.status
        execution.value.progress = data.progress
      }
    })

    // 节点状态更新
    socket.value.on('node:status', (data: WebSocketEvents['node:status']) => {
      console.log('Node status:', data.nodeId, data.status)

      if (execution.value) {
        const nodeExec = execution.value.nodes.find((n) => n.nodeId === data.nodeId)
        if (nodeExec) {
          nodeExec.status = data.status
        }
      }
    })

    // 实时日志
    socket.value.on('execution:log', (data: ExecutionLog) => {
      logs.value.push(data)

      // 限制日志数量
      if (logs.value.length > 1000) {
        logs.value.shift()
      }
    })

    // 性能指标
    socket.value.on('execution:metrics', (data: ExecutionMetrics) => {
      metrics.value.push(data)
    })

    // 执行错误
    socket.value.on('execution:error', (data: WebSocketEvents['execution:error']) => {
      console.error('Execution error:', data.error)

      if (execution.value) {
        execution.value.status = 'failed'
      }
    })

    // 连接错误
    socket.value.on('error', (error) => {
      console.error('WebSocket error:', error)
    })
  }

  /**
   * 断开连接
   */
  function disconnect() {
    if (socket.value) {
      socket.value.emit('unsubscribe', { executionId })
      socket.value.disconnect()
      socket.value = undefined
    }
  }

  onMounted(() => {
    connect()
  })

  onUnmounted(() => {
    disconnect()
  })

  return {
    execution,
    logs,
    metrics,
    connect,
    disconnect
  }
}
```

### 7.2 在组件中使用

```vue
<script setup lang="ts">
import { ref, computed } from 'vue'
import { useRoute } from 'vue-router'
import { useExecution } from '@/composables/useExecution'
import type { ExecutionLog } from '@/types/pipeline'

const route = useRoute()
const executionId = computed(() => route.params.id as string)

// 使用WebSocket监听执行状态
const { execution, logs, metrics } = useExecution(executionId.value)

// 过滤日志
const filteredLogs = computed(() => {
  return logs.value.filter((log) => log.level !== 'debug')
})

// 执行进度
const progress = computed(() => {
  return execution.value?.progress || 0
})

// 执行状态文本
const statusText = computed(() => {
  const statusMap = {
    running: 'Running',
    completed: 'Completed',
    failed: 'Failed',
    stopped: 'Stopped'
  }
  return execution.value ? statusMap[execution.value.status] : 'Unknown'
})
</script>

<template>
  <div class="execution-monitor">
    <!-- 执行状态 -->
    <a-card title="Execution Status">
      <a-statistic :value="statusText" />
      <a-progress :percent="progress" :status="execution?.status === 'failed' ? 'exception' : undefined" />
    </a-card>

    <!-- 实时日志 -->
    <a-card title="Logs" style="margin-top: 16px">
      <div class="log-container">
        <div v-for="(log, index) in filteredLogs" :key="index" :class="`log-item log-${log.level}`">
          <span class="log-time">{{ formatTime(log.timestamp) }}</span>
          <span class="log-level">{{ log.level.toUpperCase() }}</span>
          <span class="log-message">{{ log.message }}</span>
        </div>
      </div>
    </a-card>

    <!-- 性能指标 -->
    <a-card title="Metrics" style="margin-top: 16px">
      <div v-if="metrics.length > 0">
        <p>CPU: {{ metrics[metrics.length - 1].metrics.cpuUsage }}%</p>
        <p>Memory: {{ metrics[metrics.length - 1].metrics.memoryUsage }} MB</p>
        <p>Rows Processed: {{ metrics[metrics.length - 1].metrics.rowsProcessed }}</p>
      </div>
      <a-empty v-else description="No metrics available" />
    </a-card>
  </div>
</template>
```

---

## 8. 完整示例：Pipeline编辑器

这是一个完整的Pipeline编辑器组件示例：

```vue
<template>
  <div class="pipeline-editor">
    <!-- 顶部工具栏 -->
    <div class="editor-header">
      <a-space>
        <a-button @click="handleSave" :loading="saving">
          <template #icon><SaveOutlined /></template>
          Save
        </a-button>
        <a-button type="primary" @click="handleRun" :loading="running">
          <template #icon><PlayCircleOutlined /></template>
          Run
        </a-button>
        <a-divider type="vertical" />
        <a-button @click="handleUndo" :disabled="!canUndo">
          <UndoOutlined />
        </a-button>
        <a-button @click="handleRedo" :disabled="!canRedo">
          <RedoOutlined />
        </a-button>
      </a-space>

      <!-- 验证状态 -->
      <a-badge :count="validationErrors" :offset="[10, 0]">
        <a-button @click="showValidation = true">
          Validation
        </a-button>
      </a-badge>
    </div>

    <!-- 画布 -->
    <div ref="containerRef" class="graph-container"></div>

    <!-- 节点配置面板 -->
    <NodeConfigPanel
      v-if="selectedNode"
      :node="selectedNode"
      @update="handleNodeUpdate"
      @close="selectedNode = null"
    />

    <!-- 验证结果对话框 -->
    <a-modal v-model:open="showValidation" title="Validation Results">
      <ValidationResults :validation="validation" />
    </a-modal>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, watch } from 'vue'
import { useRoute, useRouter } from 'vue-router'
import { Graph } from '@antv/x6'
import type { Pipeline, Node } from '@/types/pipeline'
import { graphToPipeline, pipelineToGraph } from '@/utils/pipelineTransform'
import { validatePipeline } from '@/utils/validation'
import { pipelineApi } from '@/api/pipeline'
import { message } from 'ant-design-vue'
import {
  SaveOutlined,
  PlayCircleOutlined,
  UndoOutlined,
  RedoOutlined
} from '@ant-design/icons-vue'

const route = useRoute()
const router = useRouter()

const containerRef = ref<HTMLElement>()
const graph = ref<Graph>()
const pipeline = ref<Pipeline | null>(null)
const selectedNode = ref<Node | null>(null)
const showValidation = ref(false)
const saving = ref(false)
const running = ref(false)

// 验证
const validation = computed(() => {
  return pipeline.value ? validatePipeline(pipeline.value) : null
})

const validationErrors = computed(() => {
  return validation.value?.errors.length || 0
})

// 撤销重做
const canUndo = computed(() => graph.value?.canUndo() || false)
const canRedo = computed(() => graph.value?.canRedo() || false)

/**
 * 初始化Graph
 */
function initGraph() {
  if (!containerRef.value) return

  graph.value = new Graph({
    container: containerRef.value,
    autoResize: true,
    // ... 其他配置
  })

  // 绑定事件
  graph.value.on('node:click', ({ node }) => {
    const nodeData = node.getData()
    selectedNode.value = nodeData
  })

  graph.value.on('blank:click', () => {
    selectedNode.value = null
  })

  // 监听变化
  graph.value.on('cell:added cell:removed cell:changed', () => {
    syncPipeline()
  })
}

/**
 * 同步Pipeline数据
 */
function syncPipeline() {
  if (!graph.value) return

  const pipelineData = graphToPipeline(graph.value, pipeline.value || undefined)
  pipeline.value = {
    ...pipeline.value!,
    ...pipelineData
  }
}

/**
 * 加载Pipeline
 */
async function loadPipeline() {
  try {
    const response = await pipelineApi.getById(route.params.id as string)
    pipeline.value = response.data

    // 加载到Graph
    if (graph.value && pipeline.value) {
      pipelineToGraph(pipeline.value, graph.value)
    }
  } catch (error) {
    message.error('Failed to load pipeline')
    console.error(error)
  }
}

/**
 * 保存Pipeline
 */
async function handleSave() {
  if (!pipeline.value) return

  // 验证
  const validationResult = validatePipeline(pipeline.value)
  if (!validationResult.valid) {
    message.error('Please fix validation errors before saving')
    showValidation.value = true
    return
  }

  saving.value = true
  try {
    await pipelineApi.update(pipeline.value.id, {
      name: pipeline.value.name,
      description: pipeline.value.description,
      graph: pipeline.value.graph,
      configuration: pipeline.value.configuration
    })
    message.success('Pipeline saved successfully')
  } catch (error) {
    message.error('Failed to save pipeline')
    console.error(error)
  } finally {
    saving.value = false
  }
}

/**
 * 运行Pipeline
 */
async function handleRun() {
  if (!pipeline.value) return

  running.value = true
  try {
    const response = await pipelineApi.execute(pipeline.value.id)
    message.success('Pipeline execution started')

    // 导航到执行监控页面
    router.push(`/executions/${response.data.executionId}`)
  } catch (error) {
    message.error('Failed to start pipeline execution')
    console.error(error)
  } finally {
    running.value = false
  }
}

/**
 * 撤销
 */
function handleUndo() {
  graph.value?.undo()
}

/**
 * 重做
 */
function handleRedo() {
  graph.value?.redo()
}

/**
 * 更新节点
 */
function handleNodeUpdate(nodeId: string, config: any) {
  if (!graph.value) return

  const node = graph.value.getCellById(nodeId)
  if (node) {
    node.setData({
      ...node.getData(),
      config
    })
  }

  selectedNode.value = null
}

onMounted(() => {
  initGraph()
  loadPipeline()
})
</script>

<style scoped lang="less">
.pipeline-editor {
  display: flex;
  flex-direction: column;
  height: 100vh;
}

.editor-header {
  padding: 16px;
  border-bottom: 1px solid #e8e8e8;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.graph-container {
  flex: 1;
  position: relative;
}
</style>
```

---

## 总结

这套数据规范提供了：

✅ **完整的类型安全** - TypeScript类型定义覆盖所有数据结构
✅ **便捷的工具函数** - Graph↔Pipeline转换、节点创建、验证等
✅ **实战示例** - 涵盖创建、编辑、保存、运行等完整流程
✅ **最佳实践** - 类型守卫、实时验证、WebSocket通信等

通过这些示例，你可以：
1. 快速开始开发Pipeline Builder前端
2. 确保类型安全和数据一致性
3. 实现完整的Pipeline生命周期管理
4. 提供良好的用户体验（验证提示、实时反馈等）

---

**文档版本**: v1.0
**创建日期**: 2025-01-15
