# Pipeline Builder 技术预研与架构设计文档

## 第三部分：核心模块详细设计

---

## 1. 图编辑器模块

### 1.1 模块概述

图编辑器是 Pipeline Builder 的核心模块，负责提供可视化的 DAG（有向无环图）编辑能力。基于 AntV X6 实现，支持节点拖拽、连线、缩放、撤销重做等丰富功能。

### 1.2 核心 Composable：useGraph

```typescript
// composables/useGraph.ts
import { ref, onUnmounted } from 'vue'
import { Graph, Node, Edge } from '@antv/x6'
import { Selection } from '@antv/x6-plugin-selection'
import { Snapline } from '@antv/x6-plugin-snapline'
import { Keyboard } from '@antv/x6-plugin-keyboard'
import { Clipboard } from '@antv/x6-plugin-clipboard'
import { History } from '@antv/x6-plugin-history'
import { Transform } from '@antv/x6-plugin-transform'
import { MiniMap } from '@antv/x6-plugin-minimap'
import { Scroller } from '@antv/x6-plugin-scroller'
import { usePipelineStore } from '@/stores/modules/pipeline'

export function useGraph() {
  const graph = ref<Graph | null>(null)
  const pipelineStore = usePipelineStore()

  /**
   * 初始化图实例
   */
  function initGraph(container: HTMLElement, options: GraphOptions = {}) {
    // 创建 Graph 实例
    graph.value = new Graph({
      container,
      width: container.clientWidth,
      height: container.clientHeight,
      autoResize: true,

      // 网格配置
      grid: {
        size: 10,
        visible: true,
        type: 'dot',
        args: {
          color: '#a0a0a0',
          thickness: 1
        }
      },

      // 画布拖拽
      panning: {
        enabled: true,
        modifiers: 'space'
      },

      // 鼠标滚轮缩放
      mousewheel: {
        enabled: true,
        modifiers: ['ctrl', 'meta'],
        minScale: 0.1,
        maxScale: 4
      },

      // 连线配置
      connecting: {
        snap: true,
        allowBlank: false,
        allowLoop: false,
        allowNode: false,
        allowEdge: false,
        highlight: true,

        // 连接桩高亮
        validateMagnet({ magnet }) {
          return magnet.getAttribute('port-group') !== 'in'
        },

        // 连接验证
        validateConnection({ sourceView, targetView, sourceMagnet, targetMagnet }) {
          // 不能连接自己
          if (sourceView === targetView) {
            return false
          }

          // 只能从输出端口连接到输入端口
          const sourcePortGroup = sourceMagnet?.getAttribute('port-group')
          const targetPortGroup = targetMagnet?.getAttribute('port-group')

          if (sourcePortGroup !== 'out' || targetPortGroup !== 'in') {
            return false
          }

          return true
        },

        // 连接线路由
        router: {
          name: 'manhattan',
          args: {
            padding: 10,
            step: 10
          }
        },

        // 连接线连接器
        connector: {
          name: 'rounded',
          args: {
            radius: 10
          }
        }
      },

      // 高亮配置
      highlighting: {
        magnetAvailable: {
          name: 'stroke',
          args: {
            attrs: {
              fill: '#fff',
              stroke: '#47C769',
              strokeWidth: 3
            }
          }
        },
        magnetAdsorbed: {
          name: 'stroke',
          args: {
            attrs: {
              fill: '#fff',
              stroke: '#31d0c6',
              strokeWidth: 3
            }
          }
        }
      }
    })

    // 注册插件
    registerPlugins()

    // 注册节点
    registerNodes()

    // 绑定事件
    bindEvents()

    // 加载数据
    if (options.pipelineId) {
      loadPipelineData(options.pipelineId)
    }

    return graph.value
  }

  /**
   * 注册插件
   */
  function registerPlugins() {
    if (!graph.value) return

    // 框选
    graph.value.use(
      new Selection({
        enabled: true,
        multiple: true,
        rubberband: true,
        movable: true,
        showNodeSelectionBox: true,
        filter: ['group-node']
      })
    )

    // 对齐线
    graph.value.use(
      new Snapline({
        enabled: true,
        sharp: true
      })
    )

    // 快捷键
    graph.value.use(
      new Keyboard({
        enabled: true,
        global: true
      })
    )

    // 剪贴板
    graph.value.use(
      new Clipboard({
        enabled: true
      })
    )

    // 撤销重做
    graph.value.use(
      new History({
        enabled: true,
        stackSize: 50
      })
    )

    // 节点变形
    graph.value.use(
      new Transform({
        resizing: {
          enabled: true,
          minWidth: 100,
          minHeight: 60,
          preserveAspectRatio: false
        },
        rotating: false
      })
    )

    // 小地图
    graph.value.use(
      new MiniMap({
        container: document.getElementById('minimap')!,
        width: 200,
        height: 150,
        padding: 10,
        scalable: false,
        minScale: 0.1,
        maxScale: 1
      })
    )

    // 画布滚动
    graph.value.use(
      new Scroller({
        enabled: true,
        pannable: true,
        pageVisible: false,
        pageBreak: false
      })
    )
  }

  /**
   * 注册自定义节点
   */
  function registerNodes() {
    // 数据源节点
    Graph.registerNode('source-node', {
      inherit: 'rect',
      width: 200,
      height: 80,
      attrs: {
        body: {
          strokeWidth: 2,
          stroke: '#1890ff',
          fill: '#e6f7ff',
          rx: 6,
          ry: 6
        },
        label: {
          fontSize: 14,
          fill: '#262626',
          textWrap: {
            width: 180,
            ellipsis: true
          }
        }
      },
      ports: {
        groups: {
          out: {
            position: 'right',
            attrs: {
              circle: {
                r: 6,
                magnet: true,
                stroke: '#1890ff',
                strokeWidth: 2,
                fill: '#fff'
              }
            }
          }
        },
        items: [
          { id: 'out-1', group: 'out' }
        ]
      }
    })

    // 转换节点
    Graph.registerNode('transform-node', {
      inherit: 'rect',
      width: 200,
      height: 80,
      attrs: {
        body: {
          strokeWidth: 2,
          stroke: '#52c41a',
          fill: '#f6ffed',
          rx: 6,
          ry: 6
        },
        label: {
          fontSize: 14,
          fill: '#262626',
          textWrap: {
            width: 180,
            ellipsis: true
          }
        }
      },
      ports: {
        groups: {
          in: {
            position: 'left',
            attrs: {
              circle: {
                r: 6,
                magnet: true,
                stroke: '#52c41a',
                strokeWidth: 2,
                fill: '#fff'
              }
            }
          },
          out: {
            position: 'right',
            attrs: {
              circle: {
                r: 6,
                magnet: true,
                stroke: '#52c41a',
                strokeWidth: 2,
                fill: '#fff'
              }
            }
          }
        },
        items: [
          { id: 'in-1', group: 'in' },
          { id: 'out-1', group: 'out' }
        ]
      }
    })

    // 输出节点
    Graph.registerNode('sink-node', {
      inherit: 'rect',
      width: 200,
      height: 80,
      attrs: {
        body: {
          strokeWidth: 2,
          stroke: '#fa8c16',
          fill: '#fff7e6',
          rx: 6,
          ry: 6
        },
        label: {
          fontSize: 14,
          fill: '#262626',
          textWrap: {
            width: 180,
            ellipsis: true
          }
        }
      },
      ports: {
        groups: {
          in: {
            position: 'left',
            attrs: {
              circle: {
                r: 6,
                magnet: true,
                stroke: '#fa8c16',
                strokeWidth: 2,
                fill: '#fff'
              }
            }
          }
        },
        items: [
          { id: 'in-1', group: 'in' }
        ]
      }
    })
  }

  /**
   * 绑定事件
   */
  function bindEvents() {
    if (!graph.value) return

    // 节点点击
    graph.value.on('node:click', ({ node }) => {
      console.log('Node clicked:', node.id)
    })

    // 节点双击
    graph.value.on('node:dblclick', ({ node }) => {
      // 打开配置面板
      openConfigPanel(node)
    })

    // 边点击
    graph.value.on('edge:click', ({ edge }) => {
      console.log('Edge clicked:', edge.id)
    })

    // 节点添加
    graph.value.on('node:added', ({ node }) => {
      pipelineStore.addNode(nodeToData(node))
    })

    // 节点删除
    graph.value.on('node:removed', ({ node }) => {
      pipelineStore.removeNode(node.id)
    })

    // 边添加
    graph.value.on('edge:added', ({ edge }) => {
      pipelineStore.addEdge(edgeToData(edge))
    })

    // 边删除
    graph.value.on('edge:removed', ({ edge }) => {
      pipelineStore.removeEdge(edge.id)
    })

    // 节点移动
    graph.value.on('node:moved', ({ node }) => {
      const position = node.position()
      pipelineStore.updateNode(node.id, { x: position.x, y: position.y })
    })

    // 选择变化
    graph.value.on('selection:changed', ({ selected }) => {
      const selectedIds = selected.map(cell => cell.id)
      pipelineStore.selectNodes(selectedIds)
    })

    // 快捷键
    graph.value.bindKey('delete', () => {
      const selectedCells = graph.value!.getSelectedCells()
      if (selectedCells.length) {
        graph.value!.removeCells(selectedCells)
      }
    })

    graph.value.bindKey('ctrl+c', () => {
      const selectedCells = graph.value!.getSelectedCells()
      if (selectedCells.length) {
        graph.value!.copy(selectedCells)
      }
    })

    graph.value.bindKey('ctrl+v', () => {
      if (!graph.value!.isClipboardEmpty()) {
        const cells = graph.value!.paste({ offset: 32 })
        graph.value!.cleanSelection()
        graph.value!.select(cells)
      }
    })

    graph.value.bindKey('ctrl+z', () => {
      graph.value!.undo()
    })

    graph.value.bindKey('ctrl+shift+z', () => {
      graph.value!.redo()
    })
  }

  /**
   * 添加节点
   */
  function addNode(nodeData: NodeData) {
    if (!graph.value) return

    const node = graph.value.addNode({
      shape: `${nodeData.category}-node`,
      x: nodeData.x || 100,
      y: nodeData.y || 100,
      label: nodeData.label,
      data: nodeData
    })

    return node
  }

  /**
   * 添加边
   */
  function addEdge(edgeData: EdgeData) {
    if (!graph.value) return

    const edge = graph.value.addEdge({
      source: { cell: edgeData.source, port: edgeData.sourcePort },
      target: { cell: edgeData.target, port: edgeData.targetPort },
      attrs: {
        line: {
          stroke: '#8f8f8f',
          strokeWidth: 2,
          targetMarker: {
            name: 'block',
            width: 12,
            height: 8
          }
        }
      }
    })

    return edge
  }

  /**
   * 缩放
   */
  function zoom(factor: number) {
    if (!graph.value) return
    graph.value.zoom(factor)
  }

  /**
   * 缩放到适应
   */
  function zoomToFit() {
    if (!graph.value) return
    graph.value.zoomToFit({ padding: 20, maxScale: 1 })
  }

  /**
   * 撤销
   */
  function undo() {
    if (!graph.value) return
    graph.value.undo()
  }

  /**
   * 重做
   */
  function redo() {
    if (!graph.value) return
    graph.value.redo()
  }

  /**
   * 销毁图实例
   */
  function destroyGraph() {
    if (graph.value) {
      graph.value.dispose()
      graph.value = null
    }
  }

  // 组件卸载时销毁
  onUnmounted(() => {
    destroyGraph()
  })

  return {
    graph,
    initGraph,
    addNode,
    addEdge,
    zoom,
    zoomToFit,
    undo,
    redo,
    destroyGraph
  }
}

// 辅助函数
function nodeToData(node: Node): NodeData {
  const position = node.position()
  return {
    id: node.id,
    label: node.label as string,
    category: node.shape.replace('-node', ''),
    x: position.x,
    y: position.y,
    data: node.getData()
  }
}

function edgeToData(edge: Edge): EdgeData {
  const source = edge.getSourceCell()
  const target = edge.getTargetCell()
  return {
    id: edge.id,
    source: source?.id || '',
    target: target?.id || '',
    sourcePort: edge.getSourcePortId() || '',
    targetPort: edge.getTargetPortId() || ''
  }
}
```

### 1.3 节点拖拽实现

```typescript
// composables/useNodeDrag.ts
import { ref } from 'vue'
import type { Graph } from '@antv/x6'

export function useNodeDrag(graph: Graph | null) {
  const dragging = ref(false)
  const dragNodeType = ref<string>('')

  /**
   * 开始拖拽
   */
  function startDrag(nodeType: string, event: DragEvent) {
    dragging.value = true
    dragNodeType.value = nodeType

    // 设置拖拽数据
    if (event.dataTransfer) {
      event.dataTransfer.effectAllowed = 'copy'
      event.dataTransfer.setData('application/x-node-type', nodeType)
    }
  }

  /**
   * 拖拽结束
   */
  function endDrag() {
    dragging.value = false
    dragNodeType.value = ''
  }

  /**
   * 处理 drop
   */
  function handleDrop(event: DragEvent) {
    if (!graph) return

    event.preventDefault()

    const nodeType = event.dataTransfer?.getData('application/x-node-type')
    if (!nodeType) return

    // 计算画布坐标
    const { left, top } = (event.target as HTMLElement).getBoundingClientRect()
    const x = event.clientX - left
    const y = event.clientY - top

    // 转换为图坐标
    const localPoint = graph.clientToLocal(x, y)

    // 添加节点
    graph.addNode({
      shape: `${nodeType}-node`,
      x: localPoint.x,
      y: localPoint.y,
      label: getNodeLabel(nodeType)
    })

    endDrag()
  }

  return {
    dragging,
    dragNodeType,
    startDrag,
    endDrag,
    handleDrop
  }
}

function getNodeLabel(nodeType: string): string {
  const labels: Record<string, string> = {
    'source': 'Data Source',
    'transform': 'Transform',
    'sink': 'Data Sink'
  }
  return labels[nodeType] || 'Node'
}
```

---

## 2. 配置管理模块

### 2.1 动态表单构建器

```typescript
// composables/useFormBuilder.ts
import { ref, computed } from 'vue'
import type { FormSchema, FormModel } from '@/types'

export function useFormBuilder(schema: FormSchema) {
  const model = ref<FormModel>({})
  const errors = ref<Record<string, string>>({})

  /**
   * 初始化表单模型
   */
  function initModel(initialData?: Record<string, any>) {
    schema.fields.forEach(field => {
      model.value[field.name] = initialData?.[field.name] ?? field.defaultValue
    })
  }

  /**
   * 验证表单
   */
  async function validate(): Promise<boolean> {
    errors.value = {}
    let isValid = true

    for (const field of schema.fields) {
      const value = model.value[field.name]

      // 必填验证
      if (field.required && !value) {
        errors.value[field.name] = `${field.label} 是必填项`
        isValid = false
        continue
      }

      // 自定义验证
      if (field.validator) {
        const error = await field.validator(value, model.value)
        if (error) {
          errors.value[field.name] = error
          isValid = false
        }
      }

      // 类型验证
      if (value && field.type === 'number' && isNaN(Number(value))) {
        errors.value[field.name] = `${field.label} 必须是数字`
        isValid = false
      }

      if (value && field.type === 'email' && !isValidEmail(value)) {
        errors.value[field.name] = `${field.label} 格式不正确`
        isValid = false
      }
    }

    return isValid
  }

  /**
   * 重置表单
   */
  function reset() {
    schema.fields.forEach(field => {
      model.value[field.name] = field.defaultValue
    })
    errors.value = {}
  }

  /**
   * 获取表单数据
   */
  function getFormData() {
    return { ...model.value }
  }

  return {
    model,
    errors,
    initModel,
    validate,
    reset,
    getFormData
  }
}

function isValidEmail(email: string): boolean {
  const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
  return re.test(email)
}
```

### 2.2 节点配置 Schema

```typescript
// config/nodeSchemas.ts
import type { FormSchema } from '@/types'

/**
 * MySQL Source 配置
 */
export const mysqlSourceSchema: FormSchema = {
  fields: [
    {
      name: 'connectionId',
      label: '数据库连接',
      type: 'select',
      required: true,
      options: [], // 动态加载
      props: {
        placeholder: '选择数据库连接'
      }
    },
    {
      name: 'table',
      label: '表名',
      type: 'input',
      required: true,
      props: {
        placeholder: '输入表名'
      }
    },
    {
      name: 'columns',
      label: '列',
      type: 'select',
      mode: 'tags',
      props: {
        placeholder: '选择列（留空表示全部）'
      }
    },
    {
      name: 'where',
      label: 'WHERE 条件',
      type: 'textarea',
      props: {
        placeholder: '例：id > 100',
        rows: 3
      }
    },
    {
      name: 'limit',
      label: '限制行数',
      type: 'number',
      defaultValue: 0,
      props: {
        placeholder: '0 表示不限制',
        min: 0
      }
    }
  ]
}

/**
 * SQL Transform 配置
 */
export const sqlTransformSchema: FormSchema = {
  fields: [
    {
      name: 'sql',
      label: 'SQL 语句',
      type: 'code',
      language: 'sql',
      required: true,
      validator: async (value: string) => {
        if (!value.trim()) {
          return 'SQL 语句不能为空'
        }
        // 可以添加 SQL 语法检查
        return null
      }
    },
    {
      name: 'validateSchema',
      label: '验证输出 Schema',
      type: 'switch',
      defaultValue: true
    }
  ]
}

/**
 * Python Script 配置
 */
export const pythonScriptSchema: FormSchema = {
  fields: [
    {
      name: 'code',
      label: 'Python 代码',
      type: 'code',
      language: 'python',
      required: true,
      validator: async (value: string) => {
        if (!value.trim()) {
          return 'Python 代码不能为空'
        }
        return null
      }
    },
    {
      name: 'requirements',
      label: '依赖包',
      type: 'select',
      mode: 'tags',
      props: {
        placeholder: '例：pandas, numpy'
      }
    }
  ]
}

/**
 * 根据节点类型获取 Schema
 */
export function getNodeSchema(nodeType: string): FormSchema {
  const schemas: Record<string, FormSchema> = {
    'mysql-source': mysqlSourceSchema,
    'sql-transform': sqlTransformSchema,
    'python-script': pythonScriptSchema,
    // ... 其他节点类型
  }

  return schemas[nodeType] || { fields: [] }
}
```

### 2.3 配置面板组件

```vue
<!-- components/config/ConfigPanel.vue -->
<template>
  <a-drawer
    v-model:open="visible"
    :title="title"
    width="600"
    :body-style="{ paddingBottom: '80px' }"
    @close="handleClose"
  >
    <a-form
      :model="formModel"
      :label-col="{ span: 6 }"
      :wrapper-col="{ span: 18 }"
    >
      <a-form-item
        v-for="field in schema.fields"
        :key="field.name"
        :label="field.label"
        :required="field.required"
        :validate-status="errors[field.name] ? 'error' : ''"
        :help="errors[field.name]"
      >
        <!-- 普通输入框 -->
        <a-input
          v-if="field.type === 'input'"
          v-model:value="formModel[field.name]"
          v-bind="field.props"
        />

        <!-- 数字输入框 -->
        <a-input-number
          v-else-if="field.type === 'number'"
          v-model:value="formModel[field.name]"
          v-bind="field.props"
          style="width: 100%"
        />

        <!-- 选择框 -->
        <a-select
          v-else-if="field.type === 'select'"
          v-model:value="formModel[field.name]"
          v-bind="field.props"
          :mode="field.mode"
        >
          <a-select-option
            v-for="option in field.options"
            :key="option.value"
            :value="option.value"
          >
            {{ option.label }}
          </a-select-option>
        </a-select>

        <!-- 文本域 -->
        <a-textarea
          v-else-if="field.type === 'textarea'"
          v-model:value="formModel[field.name]"
          v-bind="field.props"
        />

        <!-- 开关 -->
        <a-switch
          v-else-if="field.type === 'switch'"
          v-model:checked="formModel[field.name]"
        />

        <!-- 代码编辑器 -->
        <MonacoEditor
          v-else-if="field.type === 'code'"
          v-model="formModel[field.name]"
          :language="field.language"
          height="300px"
        />
      </a-form-item>
    </a-form>

    <template #footer>
      <a-space>
        <a-button @click="handleClose">取消</a-button>
        <a-button
          v-if="showTestButton"
          :loading="testing"
          @click="handleTest"
        >
          测试连接
        </a-button>
        <a-button
          type="primary"
          :loading="saving"
          @click="handleSave"
        >
          保存
        </a-button>
      </a-space>
    </template>
  </a-drawer>
</template>

<script setup lang="ts">
import { ref, computed, watch } from 'vue'
import { message } from 'ant-design-vue'
import { useFormBuilder } from '@/composables/useFormBuilder'
import { getNodeSchema } from '@/config/nodeSchemas'
import MonacoEditor from './MonacoEditor.vue'

const props = defineProps<{
  nodeId: string
  nodeType: string
  nodeConfig?: Record<string, any>
}>()

const emit = defineEmits<{
  (e: 'save', config: Record<string, any>): void
  (e: 'close'): void
}>()

const visible = ref(true)
const testing = ref(false)
const saving = ref(false)

const schema = computed(() => getNodeSchema(props.nodeType))
const title = computed(() => `配置 ${props.nodeType}`)

const showTestButton = computed(() => {
  return ['mysql-source', 'postgresql-source'].includes(props.nodeType)
})

const {
  model: formModel,
  errors,
  initModel,
  validate,
  getFormData
} = useFormBuilder(schema.value)

// 初始化表单数据
initModel(props.nodeConfig)

async function handleTest() {
  testing.value = true
  try {
    // 调用测试连接 API
    await testConnection(getFormData())
    message.success('连接测试成功')
  } catch (error) {
    message.error('连接测试失败：' + error.message)
  } finally {
    testing.value = false
  }
}

async function handleSave() {
  const isValid = await validate()
  if (!isValid) {
    message.warning('请检查表单填写')
    return
  }

  saving.value = true
  try {
    const config = getFormData()
    emit('save', config)
    message.success('保存成功')
    visible.value = false
  } catch (error) {
    message.error('保存失败：' + error.message)
  } finally {
    saving.value = false
  }
}

function handleClose() {
  visible.value = false
  emit('close')
}
</script>
```

---

## 3. 执行监控模块

### 3.1 WebSocket 实时通信

```typescript
// composables/useWebSocket.ts
import { ref, onUnmounted } from 'vue'
import { io, Socket } from 'socket.io-client'
import { useUserStore } from '@/stores/modules/user'

export function useWebSocket() {
  const socket = ref<Socket | null>(null)
  const connected = ref(false)
  const reconnectAttempts = ref(0)
  const maxReconnectAttempts = 5

  const eventHandlers = new Map<string, Function[]>()

  /**
   * 连接 WebSocket
   */
  function connect(namespace: string = '/') {
    if (socket.value?.connected) {
      return
    }

    const userStore = useUserStore()

    socket.value = io(namespace, {
      auth: {
        token: userStore.token
      },
      reconnection: true,
      reconnectionDelay: 1000,
      reconnectionDelayMax: 5000,
      reconnectionAttempts: maxReconnectAttempts
    })

    bindSocketEvents()
  }

  /**
   * 绑定 Socket 事件
   */
  function bindSocketEvents() {
    if (!socket.value) return

    socket.value.on('connect', () => {
      console.log('WebSocket connected')
      connected.value = true
      reconnectAttempts.value = 0
    })

    socket.value.on('disconnect', (reason) => {
      console.log('WebSocket disconnected:', reason)
      connected.value = false
    })

    socket.value.on('reconnect_attempt', (attempt) => {
      console.log('Reconnect attempt:', attempt)
      reconnectAttempts.value = attempt
    })

    socket.value.on('reconnect_failed', () => {
      console.error('Reconnection failed')
    })

    socket.value.on('error', (error) => {
      console.error('WebSocket error:', error)
    })
  }

  /**
   * 监听事件
   */
  function on(event: string, handler: Function) {
    if (!eventHandlers.has(event)) {
      eventHandlers.set(event, [])
    }
    eventHandlers.get(event)!.push(handler)

    socket.value?.on(event, handler as any)
  }

  /**
   * 取消监听
   */
  function off(event: string, handler?: Function) {
    if (handler) {
      socket.value?.off(event, handler as any)

      const handlers = eventHandlers.get(event)
      if (handlers) {
        const index = handlers.indexOf(handler)
        if (index > -1) {
          handlers.splice(index, 1)
        }
      }
    } else {
      socket.value?.off(event)
      eventHandlers.delete(event)
    }
  }

  /**
   * 发送消息
   */
  function emit(event: string, data?: any) {
    socket.value?.emit(event, data)
  }

  /**
   * 断开连接
   */
  function disconnect() {
    if (socket.value) {
      // 移除所有事件监听
      eventHandlers.forEach((handlers, event) => {
        handlers.forEach(handler => {
          socket.value?.off(event, handler as any)
        })
      })
      eventHandlers.clear()

      socket.value.disconnect()
      socket.value = null
      connected.value = false
    }
  }

  // 组件卸载时断开连接
  onUnmounted(() => {
    disconnect()
  })

  return {
    socket,
    connected,
    reconnectAttempts,
    connect,
    on,
    off,
    emit,
    disconnect
  }
}
```

### 3.2 执行状态监控

```typescript
// composables/useExecution.ts
import { ref, computed, onMounted, onUnmounted } from 'vue'
import { useExecutionStore } from '@/stores/modules/execution'
import { useWebSocket } from './useWebSocket'
import type { Execution, ExecutionLog, Metrics } from '@/types'

export function useExecution(executionId: string) {
  const executionStore = useExecutionStore()
  const { connect, disconnect, on } = useWebSocket()

  const loading = ref(false)

  // 从 Store 获取数据
  const execution = computed(() => executionStore.currentExecution)
  const logs = computed(() => executionStore.logs)
  const metrics = computed(() => executionStore.metrics)

  // 计算属性
  const status = computed(() => execution.value?.status || 'unknown')
  const progress = computed(() => {
    if (!execution.value) return 0
    const total = execution.value.totalTasks
    const completed = execution.value.completedTasks
    return total > 0 ? Math.round((completed / total) * 100) : 0
  })

  const isRunning = computed(() => status.value === 'running')
  const isCompleted = computed(() => status.value === 'completed')
  const isFailed = computed(() => status.value === 'failed')

  /**
   * 加载执行详情
   */
  async function loadExecution() {
    loading.value = true
    try {
      await executionStore.loadExecution(executionId)
    } catch (error) {
      console.error('Failed to load execution:', error)
    } finally {
      loading.value = false
    }
  }

  /**
   * 启动实时监控
   */
  function startMonitoring() {
    connect(`/executions/${executionId}`)

    // 监听状态更新
    on('status-update', (data: any) => {
      executionStore.updateExecutionStatus(executionId, data.status)
    })

    // 监听日志
    on('log', (log: ExecutionLog) => {
      executionStore.addLog(log)
    })

    // 监听指标
    on('metric', (metric: Metrics) => {
      executionStore.updateMetrics(metric)
    })

    // 监听任务完成
    on('task-completed', (data: any) => {
      console.log('Task completed:', data)
    })

    // 监听执行完成
    on('execution-completed', (data: any) => {
      console.log('Execution completed:', data)
      executionStore.updateExecutionStatus(executionId, 'completed')
    })

    // 监听执行失败
    on('execution-failed', (data: any) => {
      console.error('Execution failed:', data)
      executionStore.updateExecutionStatus(executionId, 'failed')
    })
  }

  /**
   * 停止监控
   */
  function stopMonitoring() {
    disconnect()
  }

  /**
   * 停止执行
   */
  async function stopExecution() {
    try {
      await executionStore.stopExecution(executionId)
    } catch (error) {
      console.error('Failed to stop execution:', error)
      throw error
    }
  }

  // 挂载时加载数据并开始监控
  onMounted(() => {
    loadExecution()
    startMonitoring()
  })

  // 卸载时停止监控
  onUnmounted(() => {
    stopMonitoring()
  })

  return {
    loading,
    execution,
    logs,
    metrics,
    status,
    progress,
    isRunning,
    isCompleted,
    isFailed,
    loadExecution,
    stopExecution
  }
}
```

### 3.3 日志查看器

```vue
<!-- components/execution/LogViewer.vue -->
<template>
  <div class="log-viewer">
    <!-- 工具栏 -->
    <div class="log-toolbar">
      <a-space>
        <!-- 日志级别过滤 -->
        <a-select
          v-model:value="selectedLevel"
          style="width: 120px"
          placeholder="日志级别"
        >
          <a-select-option value="all">全部</a-select-option>
          <a-select-option value="debug">DEBUG</a-select-option>
          <a-select-option value="info">INFO</a-select-option>
          <a-select-option value="warning">WARNING</a-select-option>
          <a-select-option value="error">ERROR</a-select-option>
        </a-select>

        <!-- 搜索 -->
        <a-input-search
          v-model:value="searchText"
          placeholder="搜索日志"
          style="width: 200px"
        />

        <!-- 自动滚动 -->
        <a-checkbox v-model:checked="autoScroll">
          自动滚动
        </a-checkbox>

        <!-- 清空 -->
        <a-button @click="handleClear">清空</a-button>

        <!-- 下载 -->
        <a-button @click="handleDownload">
          <DownloadOutlined />
          下载日志
        </a-button>
      </a-space>
    </div>

    <!-- 日志列表 -->
    <div ref="logContainerRef" class="log-container">
      <div
        v-for="(log, index) in filteredLogs"
        :key="index"
        :class="['log-item', `log-${log.level}`]"
      >
        <span class="log-time">{{ formatTime(log.timestamp) }}</span>
        <span class="log-level">{{ log.level.toUpperCase() }}</span>
        <span class="log-message">{{ log.message }}</span>
      </div>

      <div v-if="filteredLogs.length === 0" class="log-empty">
        暂无日志
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, watch, nextTick } from 'vue'
import { DownloadOutlined } from '@ant-design/icons-vue'
import type { ExecutionLog } from '@/types'
import dayjs from 'dayjs'

const props = defineProps<{
  logs: ExecutionLog[]
}>()

const emit = defineEmits<{
  (e: 'clear'): void
}>()

const logContainerRef = ref<HTMLElement>()
const selectedLevel = ref('all')
const searchText = ref('')
const autoScroll = ref(true)

// 过滤日志
const filteredLogs = computed(() => {
  let result = props.logs

  // 级别过滤
  if (selectedLevel.value !== 'all') {
    result = result.filter(log => log.level === selectedLevel.value)
  }

  // 搜索过滤
  if (searchText.value) {
    const keyword = searchText.value.toLowerCase()
    result = result.filter(log =>
      log.message.toLowerCase().includes(keyword)
    )
  }

  return result
})

// 自动滚动到底部
watch(
  () => props.logs.length,
  () => {
    if (autoScroll.value) {
      nextTick(() => {
        scrollToBottom()
      })
    }
  }
)

function scrollToBottom() {
  if (logContainerRef.value) {
    logContainerRef.value.scrollTop = logContainerRef.value.scrollHeight
  }
}

function formatTime(timestamp: string) {
  return dayjs(timestamp).format('HH:mm:ss.SSS')
}

function handleClear() {
  emit('clear')
}

function handleDownload() {
  const content = props.logs
    .map(log => `[${formatTime(log.timestamp)}] [${log.level.toUpperCase()}] ${log.message}`)
    .join('\n')

  const blob = new Blob([content], { type: 'text/plain' })
  const url = URL.createObjectURL(blob)
  const a = document.createElement('a')
  a.href = url
  a.download = `execution-log-${dayjs().format('YYYY-MM-DD-HHmmss')}.txt`
  a.click()
  URL.revokeObjectURL(url)
}
</script>

<style scoped lang="less">
.log-viewer {
  display: flex;
  flex-direction: column;
  height: 100%;
}

.log-toolbar {
  padding: 12px;
  border-bottom: 1px solid #f0f0f0;
}

.log-container {
  flex: 1;
  overflow-y: auto;
  padding: 12px;
  background: #1e1e1e;
  font-family: 'Monaco', 'Courier New', monospace;
  font-size: 12px;
}

.log-item {
  padding: 4px 0;
  line-height: 1.5;
}

.log-time {
  color: #858585;
  margin-right: 8px;
}

.log-level {
  display: inline-block;
  width: 60px;
  margin-right: 8px;
  font-weight: bold;
}

.log-debug {
  color: #858585;
}

.log-info {
  color: #4fc3f7;
}

.log-warning {
  color: #ffb74d;
}

.log-error {
  color: #ef5350;
}

.log-message {
  color: #d4d4d4;
}

.log-empty {
  color: #858585;
  text-align: center;
  padding: 40px 0;
}
</style>
```

---

## 4. 版本管理模块

### 4.1 版本历史

```typescript
// composables/useVersion.ts
import { ref, computed } from 'vue'
import type { Version } from '@/types'
import { versionApi } from '@/api/modules/version'

export function useVersion(pipelineId: string) {
  const versions = ref<Version[]>([])
  const loading = ref(false)
  const currentVersion = ref<Version | null>(null)
  const compareVersion = ref<Version | null>(null)

  /**
   * 加载版本列表
   */
  async function loadVersions() {
    loading.value = true
    try {
      versions.value = await versionApi.list(pipelineId)
    } catch (error) {
      console.error('Failed to load versions:', error)
      throw error
    } finally {
      loading.value = false
    }
  }

  /**
   * 创建新版本
   */
  async function createVersion(data: { message: string; tag?: string }) {
    try {
      const version = await versionApi.create(pipelineId, data)
      versions.value.unshift(version)
      return version
    } catch (error) {
      console.error('Failed to create version:', error)
      throw error
    }
  }

  /**
   * 回滚到指定版本
   */
  async function rollback(versionId: string) {
    try {
      await versionApi.rollback(pipelineId, versionId)
    } catch (error) {
      console.error('Failed to rollback:', error)
      throw error
    }
  }

  /**
   * 对比两个版本
   */
  function compareVersions(v1: Version, v2: Version) {
    currentVersion.value = v1
    compareVersion.value = v2
  }

  /**
   * 计算版本差异
   */
  const diff = computed(() => {
    if (!currentVersion.value || !compareVersion.value) {
      return null
    }

    const v1 = currentVersion.value
    const v2 = compareVersion.value

    return {
      nodesAdded: findAddedNodes(v1.nodes, v2.nodes),
      nodesRemoved: findRemovedNodes(v1.nodes, v2.nodes),
      nodesModified: findModifiedNodes(v1.nodes, v2.nodes),
      edgesAdded: findAddedEdges(v1.edges, v2.edges),
      edgesRemoved: findRemovedEdges(v1.edges, v2.edges)
    }
  })

  return {
    versions,
    loading,
    currentVersion,
    compareVersion,
    diff,
    loadVersions,
    createVersion,
    rollback,
    compareVersions
  }
}

// 辅助函数
function findAddedNodes(oldNodes: any[], newNodes: any[]) {
  const oldIds = new Set(oldNodes.map(n => n.id))
  return newNodes.filter(n => !oldIds.has(n.id))
}

function findRemovedNodes(oldNodes: any[], newNodes: any[]) {
  const newIds = new Set(newNodes.map(n => n.id))
  return oldNodes.filter(n => !newIds.has(n.id))
}

function findModifiedNodes(oldNodes: any[], newNodes: any[]) {
  const oldMap = new Map(oldNodes.map(n => [n.id, n]))
  return newNodes.filter(n => {
    const old = oldMap.get(n.id)
    return old && JSON.stringify(old) !== JSON.stringify(n)
  })
}

function findAddedEdges(oldEdges: any[], newEdges: any[]) {
  const oldIds = new Set(oldEdges.map(e => e.id))
  return newEdges.filter(e => !oldIds.has(e.id))
}

function findRemovedEdges(oldEdges: any[], newEdges: any[]) {
  const newIds = new Set(newEdges.map(e => e.id))
  return oldEdges.filter(e => !newIds.has(e.id))
}
```

---

**文档第三部分完成** ✓

最后将编写第四部分：性能优化与部署方案
