# Pipeline Builder 技术预研与架构设计文档

## 第四部分：性能优化与部署方案

---

## 1. 性能优化策略

### 1.1 渲染性能优化

#### 1.1.1 虚拟滚动

对于大数据量的列表（如日志查看器、执行历史），使用虚拟滚动技术：

```vue
<!-- 使用 vue-virtual-scroller -->
<template>
  <RecycleScroller
    class="log-scroller"
    :items="logs"
    :item-size="32"
    key-field="id"
  >
    <template #default="{ item }">
      <LogItem :log="item" />
    </template>
  </RecycleScroller>
</template>

<script setup lang="ts">
import { RecycleScroller } from 'vue-virtual-scroller'
import 'vue-virtual-scroller/dist/vue-virtual-scroller.css'
</script>
```

**优势**：
- 只渲染可见区域的元素
- 支持 10,000+ 条日志流畅滚动
- 内存占用大幅降低

#### 1.1.2 图节点优化

```typescript
// 大规模节点场景优化
import { Graph } from '@antv/x6'

const graph = new Graph({
  // ... 其他配置

  // 虚拟渲染
  virtual: {
    enabled: true,
    threshold: 100 // 超过 100 个节点启用虚拟渲染
  },

  // 异步渲染
  async: true,

  // 冻结渲染（批量操作时）
  frozen: false
})

// 批量添加节点时冻结渲染
function batchAddNodes(nodes: NodeData[]) {
  graph.freeze() // 冻结

  nodes.forEach(nodeData => {
    graph.addNode(nodeData)
  })

  graph.unfreeze() // 解冻，一次性渲染
}
```

**性能指标**：
- 1000 节点渲染时间：< 2s
- 画布交互帧率：60 FPS
- 缩放操作延迟：< 100ms

#### 1.1.3 防抖与节流

```typescript
// utils/performance.ts
import { debounce, throttle } from 'lodash-es'

/**
 * 搜索防抖（300ms）
 */
export const debounceSearch = debounce((searchFn: Function, query: string) => {
  searchFn(query)
}, 300)

/**
 * 滚动节流（100ms）
 */
export const throttleScroll = throttle((scrollFn: Function) => {
  scrollFn()
}, 100)

/**
 * 窗口 resize 节流（200ms）
 */
export const throttleResize = throttle((resizeFn: Function) => {
  resizeFn()
}, 200)
```

使用示例：

```vue
<script setup lang="ts">
import { ref, watch } from 'vue'
import { debounceSearch } from '@/utils/performance'

const searchText = ref('')

// 防抖搜索
watch(searchText, (newValue) => {
  debounceSearch(performSearch, newValue)
})

function performSearch(query: string) {
  // 实际的搜索逻辑
}
</script>
```

### 1.2 网络性能优化

#### 1.2.1 请求优化

```typescript
// api/request.ts
import axios from 'axios'
import pLimit from 'p-limit'

// 限制并发请求数
const limit = pLimit(6)

// 请求去重
const pendingRequests = new Map<string, Promise<any>>()

/**
 * 并发限制的请求
 */
export async function limitedRequest<T>(
  url: string,
  options: any
): Promise<T> {
  return limit(() => axios(url, options))
}

/**
 * 去重请求（相同请求只发送一次）
 */
export async function dedupeRequest<T>(
  url: string,
  options: any
): Promise<T> {
  const key = `${options.method || 'GET'}_${url}_${JSON.stringify(options.params || {})}`

  if (pendingRequests.has(key)) {
    return pendingRequests.get(key)!
  }

  const promise = axios(url, options).finally(() => {
    pendingRequests.delete(key)
  })

  pendingRequests.set(key, promise)

  return promise
}
```

#### 1.2.2 数据缓存

```typescript
// utils/cache.ts
interface CacheItem<T> {
  data: T
  timestamp: number
  ttl: number // 毫秒
}

class Cache {
  private cache = new Map<string, CacheItem<any>>()

  /**
   * 设置缓存
   */
  set<T>(key: string, data: T, ttl: number = 5 * 60 * 1000) {
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      ttl
    })
  }

  /**
   * 获取缓存
   */
  get<T>(key: string): T | null {
    const item = this.cache.get(key)

    if (!item) {
      return null
    }

    // 检查是否过期
    if (Date.now() - item.timestamp > item.ttl) {
      this.cache.delete(key)
      return null
    }

    return item.data as T
  }

  /**
   * 删除缓存
   */
  delete(key: string) {
    this.cache.delete(key)
  }

  /**
   * 清空缓存
   */
  clear() {
    this.cache.clear()
  }

  /**
   * 清理过期缓存
   */
  cleanup() {
    const now = Date.now()
    for (const [key, item] of this.cache.entries()) {
      if (now - item.timestamp > item.ttl) {
        this.cache.delete(key)
      }
    }
  }
}

export const cache = new Cache()

// 定期清理过期缓存
setInterval(() => {
  cache.cleanup()
}, 60 * 1000) // 每分钟清理一次
```

使用示例：

```typescript
// api/modules/pipeline.ts
import { cache } from '@/utils/cache'
import { request } from '@/utils/request'

export const pipelineApi = {
  async getById(id: string) {
    const cacheKey = `pipeline:${id}`

    // 先从缓存获取
    const cached = cache.get<Pipeline>(cacheKey)
    if (cached) {
      return cached
    }

    // 缓存未命中，请求接口
    const data = await request.get(`/api/v1/pipelines/${id}`)

    // 存入缓存（5分钟）
    cache.set(cacheKey, data, 5 * 60 * 1000)

    return data
  }
}
```

#### 1.2.3 分页加载

```typescript
// composables/usePagination.ts
import { ref, computed } from 'vue'

export function usePagination<T>(fetchFn: Function) {
  const items = ref<T[]>([])
  const loading = ref(false)
  const hasMore = ref(true)
  const page = ref(1)
  const pageSize = ref(20)
  const total = ref(0)

  /**
   * 加载数据
   */
  async function load(reset: boolean = false) {
    if (loading.value) return
    if (!hasMore.value && !reset) return

    loading.value = true

    try {
      if (reset) {
        page.value = 1
        items.value = []
        hasMore.value = true
      }

      const response = await fetchFn({
        page: page.value,
        pageSize: pageSize.value
      })

      if (reset) {
        items.value = response.items
      } else {
        items.value.push(...response.items)
      }

      total.value = response.total
      hasMore.value = items.value.length < total.value
      page.value++
    } catch (error) {
      console.error('Failed to load data:', error)
      throw error
    } finally {
      loading.value = false
    }
  }

  /**
   * 刷新
   */
  function refresh() {
    return load(true)
  }

  /**
   * 加载更多
   */
  function loadMore() {
    return load(false)
  }

  return {
    items,
    loading,
    hasMore,
    total,
    load,
    refresh,
    loadMore
  }
}
```

### 1.3 代码分割优化

#### 1.3.1 路由懒加载

```typescript
// router/routes.ts
export const routes = [
  {
    path: '/pipelines/:id/edit',
    name: 'PipelineEditor',
    // 懒加载，使用 Webpack Magic Comments
    component: () => import(
      /* webpackChunkName: "pipeline-editor" */
      /* webpackPrefetch: true */
      '@/views/pipeline/PipelineEditor.vue'
    ),
    meta: {
      title: '编辑管道'
    }
  }
]
```

#### 1.3.2 组件异步加载

```vue
<script setup lang="ts">
import { defineAsyncComponent } from 'vue'

// 异步加载重型组件
const MonacoEditor = defineAsyncComponent({
  loader: () => import('./MonacoEditor.vue'),
  loadingComponent: LoadingComponent,
  errorComponent: ErrorComponent,
  delay: 200,
  timeout: 10000
})
</script>
```

#### 1.3.3 手动代码分割

```typescript
// vite.config.ts
export default defineConfig({
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          // Vue 全家桶
          'vue-vendor': ['vue', 'vue-router', 'pinia'],

          // UI 框架
          'ui-vendor': ['ant-design-vue', '@ant-design/icons-vue'],

          // 图编辑器
          'graph-vendor': ['@antv/x6', '@antv/x6-plugin-selection'],

          // 图表库
          'chart-vendor': ['@antv/g2'],

          // 代码编辑器
          'editor-vendor': ['monaco-editor'],

          // 工具库
          'utils-vendor': ['axios', 'dayjs', 'lodash-es']
        }
      }
    },
    chunkSizeWarningLimit: 1000 // 1MB
  }
})
```

### 1.4 内存优化

#### 1.4.1 及时清理

```typescript
// composables/useGraph.ts
import { onBeforeUnmount } from 'vue'

export function useGraph() {
  const graph = ref<Graph | null>(null)

  function destroyGraph() {
    if (graph.value) {
      // 清理事件监听
      graph.value.off()

      // 销毁图实例
      graph.value.dispose()

      graph.value = null
    }
  }

  // 组件卸载前清理
  onBeforeUnmount(() => {
    destroyGraph()
  })

  return {
    graph,
    destroyGraph
  }
}
```

#### 1.4.2 WeakMap 缓存

```typescript
// 使用 WeakMap 避免内存泄漏
const nodeCache = new WeakMap<Node, NodeData>()

function cacheNodeData(node: Node, data: NodeData) {
  nodeCache.set(node, data)
}

function getNodeData(node: Node): NodeData | undefined {
  return nodeCache.get(node)
}
```

---

## 2. 打包构建优化

### 2.1 构建配置

```typescript
// vite.config.ts
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { visualizer } from 'rollup-plugin-visualizer'
import viteCompression from 'vite-plugin-compression'
import { createSvgIconsPlugin } from 'vite-plugin-svg-icons'
import path from 'path'

export default defineConfig(({ mode }) => {
  const isProd = mode === 'production'

  return {
    plugins: [
      vue(),

      // SVG 图标
      createSvgIconsPlugin({
        iconDirs: [path.resolve(process.cwd(), 'src/assets/icons')],
        symbolId: 'icon-[dir]-[name]'
      }),

      // Gzip 压缩
      isProd && viteCompression({
        algorithm: 'gzip',
        ext: '.gz',
        threshold: 10240, // 10KB 以上才压缩
        deleteOriginFile: false
      }),

      // Brotli 压缩
      isProd && viteCompression({
        algorithm: 'brotliCompress',
        ext: '.br',
        threshold: 10240
      }),

      // 打包分析
      isProd && visualizer({
        filename: 'dist/stats.html',
        open: true,
        gzipSize: true,
        brotliSize: true
      })
    ].filter(Boolean),

    resolve: {
      alias: {
        '@': path.resolve(__dirname, 'src'),
        '@components': path.resolve(__dirname, 'src/components'),
        '@views': path.resolve(__dirname, 'src/views'),
        '@stores': path.resolve(__dirname, 'src/stores'),
        '@utils': path.resolve(__dirname, 'src/utils'),
        '@api': path.resolve(__dirname, 'src/api'),
        '@types': path.resolve(__dirname, 'src/types')
      }
    },

    build: {
      target: 'es2015',
      outDir: 'dist',
      assetsDir: 'assets',
      sourcemap: !isProd,

      // 优化选项
      minify: 'terser',
      terserOptions: {
        compress: {
          drop_console: isProd,
          drop_debugger: isProd
        }
      },

      // 代码分割
      rollupOptions: {
        output: {
          manualChunks: {
            'vue-vendor': ['vue', 'vue-router', 'pinia'],
            'ui-vendor': ['ant-design-vue'],
            'graph-vendor': ['@antv/x6'],
            'editor-vendor': ['monaco-editor']
          },

          // 文件命名
          chunkFileNames: 'js/[name]-[hash].js',
          entryFileNames: 'js/[name]-[hash].js',
          assetFileNames: '[ext]/[name]-[hash].[ext]'
        }
      },

      // 分块大小警告限制
      chunkSizeWarningLimit: 1000
    },

    server: {
      port: 3000,
      open: true,
      cors: true,

      // 代理配置
      proxy: {
        '/api': {
          target: 'http://localhost:8080',
          changeOrigin: true,
          rewrite: (path) => path.replace(/^\/api/, '')
        },
        '/ws': {
          target: 'ws://localhost:8080',
          ws: true
        }
      }
    },

    // 优化依赖预构建
    optimizeDeps: {
      include: [
        'vue',
        'vue-router',
        'pinia',
        'ant-design-vue',
        'dayjs',
        'lodash-es',
        'axios'
      ],
      exclude: [
        'monaco-editor' // Monaco 不预构建
      ]
    }
  }
})
```

### 2.2 Monaco Editor 优化

Monaco Editor 体积较大（~2MB），需要特殊处理：

```typescript
// vite.config.ts
import monacoEditorPlugin from 'vite-plugin-monaco-editor'

export default defineConfig({
  plugins: [
    monacoEditorPlugin({
      // 只包含需要的语言
      languages: ['javascript', 'typescript', 'sql', 'python', 'json'],

      // 自定义 worker
      customWorkers: [
        {
          label: 'editorWorkerService',
          entry: 'monaco-editor/esm/vs/editor/editor.worker'
        }
      ]
    })
  ]
})
```

或使用 CDN 加载：

```html
<!-- index.html -->
<script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs/loader.js"></script>
<script>
  require.config({
    paths: {
      vs: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs'
    }
  })
</script>
```

### 2.3 构建产物分析

```bash
# 安装依赖
npm install -D rollup-plugin-visualizer

# 构建并生成分析报告
npm run build

# 打开 dist/stats.html 查看
```

**优化目标**：
- 首屏 JS：< 500KB (gzip)
- 总体积：< 2MB (gzip)
- 首次加载时间：< 3s (3G 网络)

---

## 3. 运行时性能监控

### 3.1 性能指标收集

```typescript
// utils/performance.ts
interface PerformanceMetrics {
  fcp: number // First Contentful Paint
  lcp: number // Largest Contentful Paint
  fid: number // First Input Delay
  cls: number // Cumulative Layout Shift
  ttfb: number // Time to First Byte
}

/**
 * 收集性能指标
 */
export function collectPerformanceMetrics(): Promise<PerformanceMetrics> {
  return new Promise((resolve) => {
    if ('PerformanceObserver' in window) {
      const metrics: Partial<PerformanceMetrics> = {}

      // FCP
      new PerformanceObserver((list) => {
        const entries = list.getEntries()
        const fcp = entries.find(entry => entry.name === 'first-contentful-paint')
        if (fcp) {
          metrics.fcp = fcp.startTime
        }
      }).observe({ entryTypes: ['paint'] })

      // LCP
      new PerformanceObserver((list) => {
        const entries = list.getEntries()
        const lastEntry = entries[entries.length - 1]
        metrics.lcp = lastEntry.startTime
      }).observe({ entryTypes: ['largest-contentful-paint'] })

      // FID
      new PerformanceObserver((list) => {
        const entries = list.getEntries()
        const fid = entries[0]
        if (fid) {
          metrics.fid = fid.processingStart - fid.startTime
        }
      }).observe({ entryTypes: ['first-input'] })

      // CLS
      new PerformanceObserver((list) => {
        let cls = 0
        for (const entry of list.getEntries()) {
          if (!(entry as any).hadRecentInput) {
            cls += (entry as any).value
          }
        }
        metrics.cls = cls
      }).observe({ entryTypes: ['layout-shift'] })

      // TTFB
      const navigationTiming = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming
      metrics.ttfb = navigationTiming.responseStart - navigationTiming.requestStart

      setTimeout(() => {
        resolve(metrics as PerformanceMetrics)
      }, 5000)
    }
  })
}

/**
 * 上报性能数据
 */
export async function reportPerformance() {
  const metrics = await collectPerformanceMetrics()

  // 上报到监控系统
  await fetch('/api/v1/metrics/performance', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      ...metrics,
      url: location.href,
      userAgent: navigator.userAgent,
      timestamp: Date.now()
    })
  })
}
```

### 3.2 错误监控

```typescript
// utils/errorTracking.ts
interface ErrorInfo {
  message: string
  stack?: string
  componentName?: string
  url: string
  userAgent: string
  timestamp: number
}

/**
 * 全局错误处理
 */
export function setupErrorTracking() {
  // 捕获 JS 错误
  window.addEventListener('error', (event) => {
    reportError({
      message: event.message,
      stack: event.error?.stack,
      url: location.href,
      userAgent: navigator.userAgent,
      timestamp: Date.now()
    })
  })

  // 捕获未处理的 Promise 拒绝
  window.addEventListener('unhandledrejection', (event) => {
    reportError({
      message: event.reason?.message || String(event.reason),
      stack: event.reason?.stack,
      url: location.href,
      userAgent: navigator.userAgent,
      timestamp: Date.now()
    })
  })
}

/**
 * Vue 错误处理
 */
export function setupVueErrorHandler(app: App) {
  app.config.errorHandler = (err, instance, info) => {
    reportError({
      message: err.message,
      stack: err.stack,
      componentName: instance?.$options.name,
      url: location.href,
      userAgent: navigator.userAgent,
      timestamp: Date.now()
    })
  }
}

/**
 * 上报错误
 */
async function reportError(error: ErrorInfo) {
  console.error('Error tracked:', error)

  try {
    await fetch('/api/v1/metrics/error', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(error)
    })
  } catch (e) {
    console.error('Failed to report error:', e)
  }
}
```

---

## 4. 部署方案

### 4.1 Docker 部署

#### 4.1.1 Dockerfile

```dockerfile
# 多阶段构建
FROM node:18-alpine AS builder

# 设置工作目录
WORKDIR /app

# 复制 package.json
COPY package*.json ./

# 安装依赖
RUN npm ci --only=production

# 复制源代码
COPY . .

# 构建
RUN npm run build

# 生产镜像
FROM nginx:alpine

# 复制构建产物
COPY --from=builder /app/dist /usr/share/nginx/html

# 复制 Nginx 配置
COPY nginx.conf /etc/nginx/conf.d/default.conf

# 暴露端口
EXPOSE 80

# 启动 Nginx
CMD ["nginx", "-g", "daemon off;"]
```

#### 4.1.2 Nginx 配置

```nginx
# nginx.conf
server {
    listen 80;
    server_name _;
    root /usr/share/nginx/html;
    index index.html;

    # Gzip 压缩
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types text/plain text/css text/xml text/javascript
               application/x-javascript application/xml+rss
               application/json application/javascript;

    # 静态资源缓存
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
    }

    # SPA 路由支持
    location / {
        try_files $uri $uri/ /index.html;
    }

    # API 代理
    location /api {
        proxy_pass http://backend:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # WebSocket 代理
    location /ws {
        proxy_pass http://backend:8080;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```

#### 4.1.3 Docker Compose

```yaml
# docker-compose.yml
version: '3.8'

services:
  frontend:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "80:80"
    environment:
      - NODE_ENV=production
    depends_on:
      - backend
    networks:
      - app-network

  backend:
    image: pipeline-builder-backend:latest
    ports:
      - "8080:8080"
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/pipeline
    depends_on:
      - db
    networks:
      - app-network

  db:
    image: postgres:15-alpine
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=pass
      - POSTGRES_DB=pipeline
    volumes:
      - postgres-data:/var/lib/postgresql/data
    networks:
      - app-network

volumes:
  postgres-data:

networks:
  app-network:
    driver: bridge
```

### 4.2 Kubernetes 部署

#### 4.2.1 Deployment

```yaml
# k8s/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: pipeline-builder-frontend
  namespace: production
spec:
  replicas: 3
  selector:
    matchLabels:
      app: pipeline-builder-frontend
  template:
    metadata:
      labels:
        app: pipeline-builder-frontend
    spec:
      containers:
      - name: frontend
        image: your-registry/pipeline-builder-frontend:latest
        ports:
        - containerPort: 80
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 5
          periodSeconds: 5
```

#### 4.2.2 Service

```yaml
# k8s/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: pipeline-builder-frontend
  namespace: production
spec:
  selector:
    app: pipeline-builder-frontend
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80
  type: ClusterIP
```

#### 4.2.3 Ingress

```yaml
# k8s/ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: pipeline-builder-ingress
  namespace: production
  annotations:
    kubernetes.io/ingress.class: nginx
    cert-manager.io/cluster-issuer: letsencrypt-prod
spec:
  tls:
  - hosts:
    - pipeline.example.com
    secretName: pipeline-tls
  rules:
  - host: pipeline.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: pipeline-builder-frontend
            port:
              number: 80
```

### 4.3 CDN 部署

#### 4.3.1 静态资源上传

```bash
#!/bin/bash
# deploy-cdn.sh

# 构建
npm run build

# 上传静态资源到 CDN
aws s3 sync dist/assets s3://your-cdn-bucket/assets \
  --cache-control "max-age=31536000, public, immutable" \
  --delete

# 上传 HTML 文件（不缓存）
aws s3 sync dist s3://your-cdn-bucket \
  --exclude "assets/*" \
  --cache-control "no-cache, no-store, must-revalidate" \
  --delete

# 创建 CloudFront 失效
aws cloudfront create-invalidation \
  --distribution-id YOUR_DISTRIBUTION_ID \
  --paths "/*"
```

#### 4.3.2 环境变量配置

```typescript
// src/config/env.ts
interface Config {
  apiBaseUrl: string
  wsBaseUrl: string
  cdnBaseUrl: string
  env: 'development' | 'staging' | 'production'
}

export const config: Config = {
  apiBaseUrl: import.meta.env.VITE_API_BASE_URL || 'http://localhost:8080',
  wsBaseUrl: import.meta.env.VITE_WS_BASE_URL || 'ws://localhost:8080',
  cdnBaseUrl: import.meta.env.VITE_CDN_BASE_URL || '',
  env: import.meta.env.VITE_ENV || 'development'
}
```

```bash
# .env.production
VITE_API_BASE_URL=https://api.example.com
VITE_WS_BASE_URL=wss://api.example.com
VITE_CDN_BASE_URL=https://cdn.example.com
VITE_ENV=production
```

### 4.4 CI/CD 流程

#### 4.4.1 GitHub Actions

```yaml
# .github/workflows/deploy.yml
name: Deploy

on:
  push:
    branches:
      - main

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Run tests
      run: npm run test

    - name: Build
      run: npm run build
      env:
        VITE_API_BASE_URL: ${{ secrets.API_BASE_URL }}
        VITE_WS_BASE_URL: ${{ secrets.WS_BASE_URL }}

    - name: Build Docker image
      run: |
        docker build -t ${{ secrets.DOCKER_REGISTRY }}/pipeline-builder-frontend:${{ github.sha }} .
        docker tag ${{ secrets.DOCKER_REGISTRY }}/pipeline-builder-frontend:${{ github.sha }} \
                   ${{ secrets.DOCKER_REGISTRY }}/pipeline-builder-frontend:latest

    - name: Login to Docker Registry
      uses: docker/login-action@v2
      with:
        registry: ${{ secrets.DOCKER_REGISTRY }}
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}

    - name: Push Docker image
      run: |
        docker push ${{ secrets.DOCKER_REGISTRY }}/pipeline-builder-frontend:${{ github.sha }}
        docker push ${{ secrets.DOCKER_REGISTRY }}/pipeline-builder-frontend:latest

    - name: Deploy to Kubernetes
      uses: azure/k8s-deploy@v4
      with:
        manifests: |
          k8s/deployment.yaml
          k8s/service.yaml
          k8s/ingress.yaml
        images: |
          ${{ secrets.DOCKER_REGISTRY }}/pipeline-builder-frontend:${{ github.sha }}
        kubeconfig: ${{ secrets.KUBE_CONFIG }}
```

---

## 5. 监控与运维

### 5.1 应用监控

```typescript
// main.ts
import { createApp } from 'vue'
import App from './App.vue'
import { setupErrorTracking, setupVueErrorHandler } from '@/utils/errorTracking'
import { reportPerformance } from '@/utils/performance'

const app = createApp(App)

// 设置错误追踪
setupErrorTracking()
setupVueErrorHandler(app)

// 上报性能指标
window.addEventListener('load', () => {
  setTimeout(() => {
    reportPerformance()
  }, 0)
})

app.mount('#app')
```

### 5.2 日志收集

```typescript
// utils/logger.ts
enum LogLevel {
  Debug = 'debug',
  Info = 'info',
  Warning = 'warning',
  Error = 'error'
}

class Logger {
  private send(level: LogLevel, message: string, data?: any) {
    const log = {
      level,
      message,
      data,
      url: location.href,
      userAgent: navigator.userAgent,
      timestamp: new Date().toISOString()
    }

    // 开发环境输出到控制台
    if (import.meta.env.DEV) {
      console[level](message, data)
      return
    }

    // 生产环境发送到服务器
    navigator.sendBeacon('/api/v1/logs', JSON.stringify(log))
  }

  debug(message: string, data?: any) {
    this.send(LogLevel.Debug, message, data)
  }

  info(message: string, data?: any) {
    this.send(LogLevel.Info, message, data)
  }

  warning(message: string, data?: any) {
    this.send(LogLevel.Warning, message, data)
  }

  error(message: string, data?: any) {
    this.send(LogLevel.Error, message, data)
  }
}

export const logger = new Logger()
```

### 5.3 告警配置

```yaml
# prometheus/alerts.yml
groups:
  - name: frontend
    interval: 30s
    rules:
      - alert: HighErrorRate
        expr: rate(frontend_errors_total[5m]) > 0.05
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High error rate detected"
          description: "Error rate is {{ $value }} errors/sec"

      - alert: SlowPageLoad
        expr: histogram_quantile(0.95, frontend_page_load_duration_seconds) > 5
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: "Slow page load detected"
          description: "95th percentile load time is {{ $value }}s"

      - alert: FrontendDown
        expr: up{job="frontend"} == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "Frontend is down"
          description: "Frontend has been down for more than 1 minute"
```

---

## 6. 安全方案

### 6.1 内容安全策略（CSP）

```html
<!-- index.html -->
<meta http-equiv="Content-Security-Policy" content="
  default-src 'self';
  script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdn.jsdelivr.net;
  style-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net;
  img-src 'self' data: https:;
  font-src 'self' data: https://cdn.jsdelivr.net;
  connect-src 'self' https://api.example.com wss://api.example.com;
  frame-ancestors 'none';
  base-uri 'self';
  form-action 'self';
">
```

### 6.2 XSS 防护

```typescript
// utils/sanitize.ts
import DOMPurify from 'dompurify'

/**
 * 清理 HTML 内容
 */
export function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'a', 'p', 'br'],
    ALLOWED_ATTR: ['href', 'target']
  })
}

/**
 * 转义 HTML 特殊字符
 */
export function escapeHtml(text: string): string {
  const div = document.createElement('div')
  div.textContent = text
  return div.innerHTML
}
```

### 6.3 HTTPS 强制

```nginx
# nginx.conf
server {
    listen 80;
    server_name example.com;

    # 重定向到 HTTPS
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name example.com;

    ssl_certificate /etc/nginx/ssl/cert.pem;
    ssl_certificate_key /etc/nginx/ssl/key.pem;

    # SSL 配置
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;
    ssl_prefer_server_ciphers on;

    # HSTS
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

    # ... 其他配置
}
```

---

## 7. 总结

### 7.1 技术栈总结

```
Frontend Stack
├── 核心框架
│   ├── Vue 3.4+ (Composition API)
│   ├── TypeScript 5.x
│   └── Vite 5.x
│
├── UI 与交互
│   ├── Ant Design Vue 4.x
│   ├── AntV X6 (图编辑器)
│   ├── AntV G2 (图表)
│   └── Monaco Editor (代码编辑)
│
├── 状态与路由
│   ├── Pinia 2.x
│   ├── Vue Router 4.x
│   └── VueUse
│
├── 通信与工具
│   ├── Axios
│   ├── Socket.io Client
│   ├── Day.js
│   └── Lodash-es
│
└── 开发与测试
    ├── ESLint + Prettier
    ├── Vitest
    ├── Playwright
    └── Husky
```

### 7.2 性能指标

| 指标 | 目标值 | 说明 |
|------|--------|------|
| FCP | < 1.5s | 首次内容绘制 |
| LCP | < 2.5s | 最大内容绘制 |
| FID | < 100ms | 首次输入延迟 |
| CLS | < 0.1 | 累积布局偏移 |
| 首屏加载 | < 3s | 3G 网络 |
| Bundle 大小 | < 500KB | Gzip 后 |
| 渲染帧率 | 60 FPS | 画布操作 |
| 节点容量 | 1000+ | 流畅编辑 |

### 7.3 部署架构

```
┌─────────────────────────────────────────────────────────────┐
│                        用户浏览器                           │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                          CDN                                │
│                    (静态资源加速)                            │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                      Load Balancer                          │
│                      (负载均衡)                              │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                    Kubernetes Cluster                       │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │
│  │  Frontend    │  │  Frontend    │  │  Frontend    │     │
│  │  Pod 1       │  │  Pod 2       │  │  Pod 3       │     │
│  └──────────────┘  └──────────────┘  └──────────────┘     │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                      Backend API                            │
└─────────────────────────────────────────────────────────────┘
```

### 7.4 下一步工作

**Phase 1: MVP 开发 (2-3 个月)**
- [ ] 完成核心图编辑器
- [ ] 实现基础节点类型（5-10 个）
- [ ] 完成执行和监控功能
- [ ] 用户认证和权限

**Phase 2: 功能完善 (2-3 个月)**
- [ ] 扩展节点类型（20+ 个）
- [ ] 版本管理和回滚
- [ ] 数据血缘追踪
- [ ] 实时协作功能

**Phase 3: 优化与上线 (1-2 个月)**
- [ ] 性能优化和测试
- [ ] 安全加固
- [ ] 部署和监控
- [ ] 文档和培训

---

**全部文档完成** ✅

这套完整的技术预研和架构设计文档涵盖了：
1. 项目概述与技术调研
2. 前端技术架构设计
3. 核心模块详细设计
4. 性能优化与部署方案

可以作为 Pipeline Builder 前端开发的指导文档。
