# Pipeline Builder 技术预研与架构设计文档

## 第二部分：前端技术架构设计

---

## 1. 整体架构设计

### 1.1 分层架构

```
┌─────────────────────────────────────────────────────────────┐
│                        表现层 (Presentation Layer)          │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │
│  │  Views 视图  │  │  Layouts     │  │  Components  │     │
│  │  页面级组件   │  │  布局组件     │  │  业务组件     │     │
│  └──────────────┘  └──────────────┘  └──────────────┘     │
└─────────────────────────────────────────────────────────────┘
                            ↕
┌─────────────────────────────────────────────────────────────┐
│                      业务逻辑层 (Business Logic Layer)        │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │
│  │ Composables  │  │   Stores     │  │  Directives  │     │
│  │ 组合式逻辑    │  │  状态管理     │  │  自定义指令   │     │
│  └──────────────┘  └──────────────┘  └──────────────┘     │
└─────────────────────────────────────────────────────────────┘
                            ↕
┌─────────────────────────────────────────────────────────────┐
│                      数据访问层 (Data Access Layer)           │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │
│  │  API 模块    │  │  WebSocket   │  │  LocalStorage│     │
│  │  HTTP 请求   │  │  实时通信     │  │  本地存储     │     │
│  └──────────────┘  └──────────────┘  └──────────────┘     │
└─────────────────────────────────────────────────────────────┘
                            ↕
┌─────────────────────────────────────────────────────────────┐
│                      基础设施层 (Infrastructure Layer)         │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │
│  │  Utils       │  │   Types      │  │   Constants  │     │
│  │  工具函数     │  │  类型定义     │  │   常量配置    │     │
│  └──────────────┘  └──────────────┘  └──────────────┘     │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 架构特点

**分层解耦**：
- 各层职责清晰，互不干扰
- 上层依赖下层，下层不依赖上层
- 通过接口和抽象隔离变化

**组件化开发**：
- 原子组件：最小粒度的 UI 单元
- 业务组件：特定业务场景的组件
- 页面组件：完整的页面级组件

**响应式架构**：
- Vue 3 响应式系统
- Pinia 状态管理
- 数据驱动视图更新

**插件化扩展**：
- 节点类型可插拔
- 功能模块可扩展
- 配置驱动的架构

---

## 2. 目录结构设计

### 2.1 完整目录结构

```
pipeline-builder-frontend/
├── public/                          # 静态资源
│   ├── favicon.ico
│   └── logo.png
│
├── src/
│   ├── api/                         # API 接口层
│   │   ├── modules/                 # API 模块
│   │   │   ├── pipeline.ts          # 管道相关 API
│   │   │   ├── execution.ts         # 执行相关 API
│   │   │   ├── connection.ts        # 连接相关 API
│   │   │   ├── lineage.ts           # 血缘相关 API
│   │   │   ├── user.ts              # 用户相关 API
│   │   │   └── auth.ts              # 认证相关 API
│   │   ├── request.ts               # Axios 封装
│   │   └── websocket.ts             # WebSocket 封装
│   │
│   ├── assets/                      # 静态资源
│   │   ├── images/                  # 图片
│   │   ├── icons/                   # 图标
│   │   ├── fonts/                   # 字体
│   │   └── styles/                  # 全局样式
│   │       ├── variables.less       # Less 变量
│   │       ├── mixins.less          # Less Mixins
│   │       ├── reset.less           # 样式重置
│   │       └── global.less          # 全局样式
│   │
│   ├── components/                  # 组件库
│   │   ├── common/                  # 通用组件
│   │   │   ├── AppHeader.vue        # 应用头部
│   │   │   ├── AppSidebar.vue       # 侧边栏
│   │   │   ├── AppFooter.vue        # 页脚
│   │   │   ├── Loading.vue          # 加载中
│   │   │   ├── Empty.vue            # 空状态
│   │   │   └── ErrorBoundary.vue    # 错误边界
│   │   │
│   │   ├── graph/                   # 图编辑器组件
│   │   │   ├── GraphCanvas.vue      # 画布主组件
│   │   │   ├── GraphToolbar.vue     # 工具栏
│   │   │   ├── NodePalette.vue      # 节点面板
│   │   │   ├── MiniMap.vue          # 小地图
│   │   │   ├── ContextMenu.vue      # 右键菜单
│   │   │   ├── Snapline.vue         # 对齐线
│   │   │   └── GraphSearch.vue      # 节点搜索
│   │   │
│   │   ├── node/                    # 节点组件
│   │   │   ├── BaseNode.vue         # 基础节点
│   │   │   ├── SourceNode.vue       # 数据源节点
│   │   │   ├── TransformNode.vue    # 转换节点
│   │   │   ├── SinkNode.vue         # 输出节点
│   │   │   └── GroupNode.vue        # 分组节点
│   │   │
│   │   ├── config/                  # 配置组件
│   │   │   ├── ConfigPanel.vue      # 配置面板
│   │   │   ├── ConfigDrawer.vue     # 配置抽屉
│   │   │   ├── FormBuilder.vue      # 动态表单
│   │   │   ├── SqlEditor.vue        # SQL 编辑器
│   │   │   ├── PythonEditor.vue     # Python 编辑器
│   │   │   └── ConnectionTest.vue   # 连接测试
│   │   │
│   │   ├── execution/               # 执行相关组件
│   │   │   ├── ExecutionStatus.vue  # 执行状态
│   │   │   ├── ExecutionControl.vue # 执行控制
│   │   │   ├── LogViewer.vue        # 日志查看器
│   │   │   ├── LogFilter.vue        # 日志过滤
│   │   │   ├── MetricsChart.vue     # 性能图表
│   │   │   └── TaskTimeline.vue     # 任务时间线
│   │   │
│   │   ├── data/                    # 数据组件
│   │   │   ├── DataPreview.vue      # 数据预览
│   │   │   ├── DataTable.vue        # 数据表格
│   │   │   ├── SchemaViewer.vue     # Schema 查看
│   │   │   ├── ColumnStats.vue      # 列统计
│   │   │   └── DataExport.vue       # 数据导出
│   │   │
│   │   ├── version/                 # 版本管理组件
│   │   │   ├── VersionHistory.vue   # 版本历史
│   │   │   ├── VersionCompare.vue   # 版本对比
│   │   │   ├── VersionTag.vue       # 版本标签
│   │   │   └── BranchTree.vue       # 分支树
│   │   │
│   │   ├── collaboration/           # 协作组件
│   │   │   ├── UserCursor.vue       # 用户光标
│   │   │   ├── CommentPanel.vue     # 评论面板
│   │   │   ├── CommentThread.vue    # 评论线程
│   │   │   └── MentionInput.vue     # @提醒输入
│   │   │
│   │   └── lineage/                 # 血缘组件
│   │       ├── LineageGraph.vue     # 血缘图
│   │       ├── LineageNode.vue      # 血缘节点
│   │       ├── LineageFilter.vue    # 血缘过滤
│   │       └── ImpactAnalysis.vue   # 影响分析
│   │
│   ├── composables/                 # 组合式函数
│   │   ├── useGraph.ts              # 图编辑器逻辑
│   │   ├── useNode.ts               # 节点操作逻辑
│   │   ├── useEdge.ts               # 边操作逻辑
│   │   ├── useExecution.ts          # 执行逻辑
│   │   ├── useWebSocket.ts          # WebSocket 逻辑
│   │   ├── useKeyboard.ts           # 键盘快捷键
│   │   ├── useClipboard.ts          # 剪贴板操作
│   │   ├── useHistory.ts            # 历史记录
│   │   ├── useSelection.ts          # 选择逻辑
│   │   ├── useValidation.ts         # 验证逻辑
│   │   └── usePermission.ts         # 权限逻辑
│   │
│   ├── directives/                  # 自定义指令
│   │   ├── loading.ts               # v-loading
│   │   ├── permission.ts            # v-permission
│   │   ├── clickOutside.ts          # v-click-outside
│   │   └── index.ts                 # 指令注册
│   │
│   ├── layouts/                     # 布局组件
│   │   ├── DefaultLayout.vue        # 默认布局
│   │   ├── EditorLayout.vue         # 编辑器布局
│   │   ├── AuthLayout.vue           # 认证布局
│   │   └── BlankLayout.vue          # 空白布局
│   │
│   ├── router/                      # 路由配置
│   │   ├── index.ts                 # 路由主文件
│   │   ├── routes.ts                # 路由配置
│   │   └── guards.ts                # 路由守卫
│   │
│   ├── stores/                      # Pinia 状态管理
│   │   ├── modules/                 # Store 模块
│   │   │   ├── app.ts               # 应用全局状态
│   │   │   ├── user.ts              # 用户状态
│   │   │   ├── pipeline.ts          # 管道状态
│   │   │   ├── execution.ts         # 执行状态
│   │   │   ├── connection.ts        # 连接状态
│   │   │   ├── lineage.ts           # 血缘状态
│   │   │   └── collaboration.ts     # 协作状态
│   │   └── index.ts                 # Store 导出
│   │
│   ├── types/                       # TypeScript 类型定义
│   │   ├── api.d.ts                 # API 类型
│   │   ├── graph.d.ts               # 图相关类型
│   │   ├── node.d.ts                # 节点类型
│   │   ├── edge.d.ts                # 边类型
│   │   ├── execution.d.ts           # 执行类型
│   │   ├── user.d.ts                # 用户类型
│   │   └── index.d.ts               # 类型导出
│   │
│   ├── utils/                       # 工具函数
│   │   ├── request.ts               # HTTP 请求工具
│   │   ├── storage.ts               # 本地存储工具
│   │   ├── date.ts                  # 日期处理工具
│   │   ├── format.ts                # 格式化工具
│   │   ├── validate.ts              # 验证工具
│   │   ├── graph.ts                 # 图算法工具
│   │   ├── dom.ts                   # DOM 操作工具
│   │   └── index.ts                 # 工具导出
│   │
│   ├── views/                       # 页面视图
│   │   ├── pipeline/                # 管道相关页面
│   │   │   ├── PipelineList.vue     # 管道列表
│   │   │   ├── PipelineEditor.vue   # 管道编辑器
│   │   │   ├── PipelineView.vue     # 管道查看
│   │   │   └── PipelineCreate.vue   # 创建管道
│   │   │
│   │   ├── execution/               # 执行相关页面
│   │   │   ├── ExecutionList.vue    # 执行列表
│   │   │   └── ExecutionDetail.vue  # 执行详情
│   │   │
│   │   ├── connection/              # 连接管理页面
│   │   │   ├── ConnectionList.vue   # 连接列表
│   │   │   └── ConnectionForm.vue   # 连接表单
│   │   │
│   │   ├── lineage/                 # 血缘页面
│   │   │   └── LineageView.vue      # 血缘查看
│   │   │
│   │   ├── settings/                # 设置页面
│   │   │   ├── UserSettings.vue     # 用户设置
│   │   │   └── SystemSettings.vue   # 系统设置
│   │   │
│   │   └── auth/                    # 认证页面
│   │       ├── Login.vue            # 登录
│   │       └── Register.vue         # 注册
│   │
│   ├── App.vue                      # 根组件
│   └── main.ts                      # 应用入口
│
├── tests/                           # 测试文件
│   ├── unit/                        # 单元测试
│   │   ├── components/              # 组件测试
│   │   ├── composables/             # Composables 测试
│   │   └── utils/                   # 工具测试
│   │
│   └── e2e/                         # E2E 测试
│       ├── pipeline.spec.ts         # 管道测试
│       ├── execution.spec.ts        # 执行测试
│       └── auth.spec.ts             # 认证测试
│
├── docs/                            # 文档
│   ├── 01-项目概述与技术调研.md
│   ├── 02-前端技术架构设计.md
│   ├── 03-核心模块详细设计.md
│   └── 04-性能优化与部署方案.md
│
├── .eslintrc.js                     # ESLint 配置
├── .prettierrc                      # Prettier 配置
├── tsconfig.json                    # TypeScript 配置
├── vite.config.ts                   # Vite 配置
├── package.json                     # 项目配置
└── README.md                        # 项目说明
```

### 2.2 目录设计原则

**按功能模块划分**：
- 相关文件放在同一目录
- 便于查找和维护
- 支持模块化开发

**分层清晰**：
- 表现层、逻辑层、数据层分离
- 职责单一，易于测试
- 降低耦合度

**可扩展性**：
- 易于添加新功能模块
- 支持插件化扩展
- 便于团队协作

---

## 3. 组件架构设计

### 3.1 组件分类

```
组件层级架构
│
├── 原子组件 (Atoms)                  # 最小粒度
│   ├── Button                       # 按钮
│   ├── Input                        # 输入框
│   ├── Icon                         # 图标
│   └── Badge                        # 徽章
│
├── 分子组件 (Molecules)              # 组合原子组件
│   ├── SearchBox                    # 搜索框 (Input + Button)
│   ├── FormItem                     # 表单项 (Label + Input)
│   ├── IconButton                   # 图标按钮 (Icon + Button)
│   └── StatusBadge                  # 状态徽章 (Badge + Text)
│
├── 组织组件 (Organisms)              # 业务功能组件
│   ├── NodePalette                  # 节点面板
│   ├── ConfigPanel                  # 配置面板
│   ├── ExecutionStatus              # 执行状态
│   └── DataPreview                  # 数据预览
│
├── 模板组件 (Templates)              # 页面模板
│   ├── EditorLayout                 # 编辑器布局
│   ├── ListLayout                   # 列表布局
│   └── DetailLayout                 # 详情布局
│
└── 页面组件 (Pages)                  # 完整页面
    ├── PipelineEditor               # 管道编辑器
    ├── PipelineList                 # 管道列表
    └── ExecutionDetail              # 执行详情
```

### 3.2 组件设计原则

#### 3.2.1 单一职责原则 (SRP)

每个组件只负责一个功能：

```vue
<!-- ❌ 不好的示例：一个组件做太多事 -->
<template>
  <div>
    <h1>{{ title }}</h1>
    <input v-model="searchText" />
    <ul>
      <li v-for="item in filteredItems" :key="item.id">
        {{ item.name }}
      </li>
    </ul>
    <button @click="loadMore">加载更多</button>
  </div>
</template>

<!-- ✅ 好的示例：职责分离 -->
<template>
  <div>
    <PageHeader :title="title" />
    <SearchBox v-model="searchText" />
    <ItemList :items="filteredItems" />
    <LoadMoreButton @load="loadMore" />
  </div>
</template>
```

#### 3.2.2 组件通信原则

**父子组件通信**：
- Props down, Events up
- 父组件通过 props 传递数据
- 子组件通过 emit 触发事件

```vue
<!-- 父组件 -->
<template>
  <ChildComponent
    :value="data"
    @change="handleChange"
  />
</template>

<!-- 子组件 -->
<script setup lang="ts">
defineProps<{ value: string }>()
const emit = defineEmits<{
  (e: 'change', value: string): void
}>()
</script>
```

**跨层级通信**：
- 使用 provide/inject
- 或使用 Pinia 状态管理

```typescript
// 祖先组件
import { provide } from 'vue'

provide('theme', { mode: 'dark' })

// 后代组件
import { inject } from 'vue'

const theme = inject('theme')
```

#### 3.2.3 组件复用原则

**高内聚，低耦合**：
- 组件内部逻辑完整
- 对外依赖最小化
- 通过 props 和 events 交互

**Composition API 逻辑复用**：

```typescript
// composables/useNode.ts
export function useNode(nodeId: string) {
  const node = ref<Node | null>(null)
  const loading = ref(false)

  async function loadNode() {
    loading.value = true
    node.value = await fetchNode(nodeId)
    loading.value = false
  }

  return {
    node,
    loading,
    loadNode
  }
}

// 在多个组件中复用
import { useNode } from '@/composables/useNode'

const { node, loading, loadNode } = useNode(props.nodeId)
```

### 3.3 关键组件设计

#### 3.3.1 GraphCanvas (画布组件)

```vue
<template>
  <div ref="containerRef" class="graph-canvas">
    <!-- X6 画布挂载点 -->
    <div ref="graphRef" class="graph-container"></div>

    <!-- 小地图 -->
    <MiniMap :graph="graph" />

    <!-- 工具栏 -->
    <GraphToolbar
      @zoom-in="handleZoomIn"
      @zoom-out="handleZoomOut"
      @fit="handleFit"
      @undo="handleUndo"
      @redo="handleRedo"
    />

    <!-- 节点面板 -->
    <NodePalette @add-node="handleAddNode" />

    <!-- 右键菜单 -->
    <ContextMenu
      v-if="contextMenu.visible"
      :x="contextMenu.x"
      :y="contextMenu.y"
      :items="contextMenu.items"
      @select="handleMenuSelect"
    />
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, onUnmounted } from 'vue'
import { Graph } from '@antv/x6'
import { useGraph } from '@/composables/useGraph'

const props = defineProps<{
  pipelineId: string
}>()

const containerRef = ref<HTMLElement>()
const graphRef = ref<HTMLElement>()
const { graph, initGraph, destroyGraph } = useGraph()

onMounted(() => {
  if (graphRef.value) {
    initGraph(graphRef.value, {
      pipelineId: props.pipelineId
    })
  }
})

onUnmounted(() => {
  destroyGraph()
})
</script>
```

**职责**：
- X6 图实例管理
- 画布事件处理
- 子组件协调

#### 3.3.2 ConfigPanel (配置面板)

```vue
<template>
  <a-drawer
    v-model:open="visible"
    title="节点配置"
    width="600"
    :body-style="{ paddingBottom: '80px' }"
  >
    <FormBuilder
      :schema="formSchema"
      :model="formModel"
      @validate="handleValidate"
    />

    <!-- SQL/Python 编辑器 -->
    <SqlEditor
      v-if="nodeType === 'sql-transform'"
      v-model="formModel.sql"
    />

    <PythonEditor
      v-if="nodeType === 'python-script'"
      v-model="formModel.code"
    />

    <template #footer>
      <a-space>
        <a-button @click="handleCancel">取消</a-button>
        <a-button @click="handleTest">测试连接</a-button>
        <a-button type="primary" @click="handleSave">保存</a-button>
      </a-space>
    </template>
  </a-drawer>
</template>

<script setup lang="ts">
import { ref, computed, watch } from 'vue'
import { useNodeConfig } from '@/composables/useNodeConfig'

const props = defineProps<{
  nodeId: string
  nodeType: string
}>()

const emit = defineEmits<{
  (e: 'save', config: any): void
  (e: 'cancel'): void
}>()

const { formSchema, formModel, validate } = useNodeConfig(props.nodeType)

async function handleSave() {
  const valid = await validate()
  if (valid) {
    emit('save', formModel.value)
  }
}
</script>
```

**职责**：
- 动态表单渲染
- 表单验证
- 代码编辑器集成

#### 3.3.3 ExecutionStatus (执行状态)

```vue
<template>
  <div class="execution-status">
    <!-- 总体状态 -->
    <a-card>
      <a-statistic
        title="执行状态"
        :value="statusText"
        :value-style="statusStyle"
      />
      <a-progress
        :percent="progress"
        :status="progressStatus"
      />
    </a-card>

    <!-- 任务列表 -->
    <TaskTimeline :tasks="tasks" />

    <!-- 日志查看 -->
    <LogViewer
      :logs="logs"
      :loading="logLoading"
      @filter="handleLogFilter"
    />

    <!-- 性能指标 -->
    <MetricsChart :metrics="metrics" />
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, onUnmounted } from 'vue'
import { useExecution } from '@/composables/useExecution'
import { useWebSocket } from '@/composables/useWebSocket'

const props = defineProps<{
  executionId: string
}>()

const {
  status,
  tasks,
  logs,
  metrics,
  loadExecution
} = useExecution(props.executionId)

const { connect, disconnect, on } = useWebSocket()

onMounted(() => {
  loadExecution()
  connect(`/executions/${props.executionId}`)

  on('status-update', (data) => {
    status.value = data.status
  })

  on('log', (data) => {
    logs.value.push(data)
  })
})

onUnmounted(() => {
  disconnect()
})
</script>
```

**职责**：
- 执行状态展示
- 实时日志流
- 性能指标可视化

---

## 4. 状态管理设计

### 4.1 Pinia Store 架构

```
State Management Architecture
│
├── App Store (全局应用状态)
│   ├── theme              # 主题配置
│   ├── language           # 语言设置
│   ├── sidebar            # 侧边栏状态
│   └── notifications      # 通知列表
│
├── User Store (用户状态)
│   ├── currentUser        # 当前用户信息
│   ├── permissions        # 用户权限
│   ├── token              # 认证令牌
│   └── preferences        # 用户偏好
│
├── Pipeline Store (管道状态)
│   ├── currentPipeline    # 当前编辑的管道
│   ├── nodes              # 节点列表
│   ├── edges              # 边列表
│   ├── selectedNodes      # 选中的节点
│   ├── history            # 历史记录栈
│   └── isDirty            # 未保存标记
│
├── Execution Store (执行状态)
│   ├── executions         # 执行列表
│   ├── currentExecution   # 当前执行
│   ├── logs               # 日志列表
│   └── metrics            # 性能指标
│
├── Connection Store (连接状态)
│   ├── connections        # 数据源连接列表
│   ├── connectionTypes    # 支持的连接类型
│   └── testResults        # 测试结果
│
└── Collaboration Store (协作状态)
    ├── onlineUsers        # 在线用户
    ├── userCursors        # 用户光标位置
    ├── comments           # 评论列表
    └── notifications      # 协作通知
```

### 4.2 Store 设计示例

#### 4.2.1 Pipeline Store

```typescript
// stores/modules/pipeline.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import type { Pipeline, Node, Edge } from '@/types'
import { pipelineApi } from '@/api/modules/pipeline'

export const usePipelineStore = defineStore('pipeline', () => {
  // State
  const currentPipeline = ref<Pipeline | null>(null)
  const nodes = ref<Node[]>([])
  const edges = ref<Edge[]>([])
  const selectedNodes = ref<string[]>([])
  const history = ref<HistoryState[]>([])
  const historyIndex = ref(-1)
  const isDirty = ref(false)

  // Getters
  const nodeCount = computed(() => nodes.value.length)
  const edgeCount = computed(() => edges.value.length)

  const canUndo = computed(() => historyIndex.value > 0)
  const canRedo = computed(() => historyIndex.value < history.value.length - 1)

  const selectedNodeData = computed(() => {
    return nodes.value.filter(node =>
      selectedNodes.value.includes(node.id)
    )
  })

  // Actions
  async function loadPipeline(id: string) {
    try {
      const pipeline = await pipelineApi.getById(id)
      currentPipeline.value = pipeline
      nodes.value = pipeline.nodes
      edges.value = pipeline.edges
      isDirty.value = false

      // 初始化历史记录
      history.value = [{
        nodes: [...nodes.value],
        edges: [...edges.value]
      }]
      historyIndex.value = 0
    } catch (error) {
      console.error('Failed to load pipeline:', error)
      throw error
    }
  }

  function addNode(node: Node) {
    nodes.value.push(node)
    markDirty()
    saveHistory()
  }

  function removeNode(id: string) {
    const index = nodes.value.findIndex(n => n.id === id)
    if (index > -1) {
      nodes.value.splice(index, 1)
      // 同时删除相关的边
      edges.value = edges.value.filter(
        e => e.source !== id && e.target !== id
      )
      markDirty()
      saveHistory()
    }
  }

  function updateNode(id: string, updates: Partial<Node>) {
    const node = nodes.value.find(n => n.id === id)
    if (node) {
      Object.assign(node, updates)
      markDirty()
      saveHistory()
    }
  }

  function addEdge(edge: Edge) {
    // 检查是否形成环
    if (wouldCreateCycle(edge)) {
      throw new Error('Cannot create cycle in DAG')
    }
    edges.value.push(edge)
    markDirty()
    saveHistory()
  }

  function removeEdge(id: string) {
    const index = edges.value.findIndex(e => e.id === id)
    if (index > -1) {
      edges.value.splice(index, 1)
      markDirty()
      saveHistory()
    }
  }

  function selectNodes(ids: string[]) {
    selectedNodes.value = ids
  }

  function clearSelection() {
    selectedNodes.value = []
  }

  async function savePipeline() {
    if (!currentPipeline.value) return

    try {
      const updated = await pipelineApi.update(
        currentPipeline.value.id,
        {
          nodes: nodes.value,
          edges: edges.value
        }
      )
      currentPipeline.value = updated
      isDirty.value = false
    } catch (error) {
      console.error('Failed to save pipeline:', error)
      throw error
    }
  }

  function undo() {
    if (canUndo.value) {
      historyIndex.value--
      restoreState(history.value[historyIndex.value])
    }
  }

  function redo() {
    if (canRedo.value) {
      historyIndex.value++
      restoreState(history.value[historyIndex.value])
    }
  }

  // Helper functions
  function markDirty() {
    isDirty.value = true
  }

  function saveHistory() {
    // 删除当前位置之后的历史
    history.value = history.value.slice(0, historyIndex.value + 1)

    // 添加新状态
    history.value.push({
      nodes: JSON.parse(JSON.stringify(nodes.value)),
      edges: JSON.parse(JSON.stringify(edges.value))
    })

    historyIndex.value = history.value.length - 1

    // 限制历史记录数量
    if (history.value.length > 50) {
      history.value.shift()
      historyIndex.value--
    }
  }

  function restoreState(state: HistoryState) {
    nodes.value = JSON.parse(JSON.stringify(state.nodes))
    edges.value = JSON.parse(JSON.stringify(state.edges))
    isDirty.value = true
  }

  function wouldCreateCycle(newEdge: Edge): boolean {
    // 使用 DFS 检测环
    const graph = new Map<string, string[]>()

    // 构建邻接表
    edges.value.forEach(edge => {
      if (!graph.has(edge.source)) {
        graph.set(edge.source, [])
      }
      graph.get(edge.source)!.push(edge.target)
    })

    // 添加新边
    if (!graph.has(newEdge.source)) {
      graph.set(newEdge.source, [])
    }
    graph.get(newEdge.source)!.push(newEdge.target)

    // DFS 检测环
    const visited = new Set<string>()
    const recStack = new Set<string>()

    function hasCycle(node: string): boolean {
      visited.add(node)
      recStack.add(node)

      const neighbors = graph.get(node) || []
      for (const neighbor of neighbors) {
        if (!visited.has(neighbor)) {
          if (hasCycle(neighbor)) {
            return true
          }
        } else if (recStack.has(neighbor)) {
          return true
        }
      }

      recStack.delete(node)
      return false
    }

    return hasCycle(newEdge.source)
  }

  return {
    // State
    currentPipeline,
    nodes,
    edges,
    selectedNodes,
    isDirty,

    // Getters
    nodeCount,
    edgeCount,
    canUndo,
    canRedo,
    selectedNodeData,

    // Actions
    loadPipeline,
    addNode,
    removeNode,
    updateNode,
    addEdge,
    removeEdge,
    selectNodes,
    clearSelection,
    savePipeline,
    undo,
    redo
  }
})
```

#### 4.2.2 Execution Store

```typescript
// stores/modules/execution.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import type { Execution, ExecutionLog, Metrics } from '@/types'
import { executionApi } from '@/api/modules/execution'

export const useExecutionStore = defineStore('execution', () => {
  // State
  const executions = ref<Execution[]>([])
  const currentExecution = ref<Execution | null>(null)
  const logs = ref<ExecutionLog[]>([])
  const metrics = ref<Metrics | null>(null)

  // Getters
  const runningExecutions = computed(() => {
    return executions.value.filter(e => e.status === 'running')
  })

  const failedExecutions = computed(() => {
    return executions.value.filter(e => e.status === 'failed')
  })

  // Actions
  async function loadExecutions(pipelineId?: string) {
    try {
      const data = await executionApi.list({ pipelineId })
      executions.value = data
    } catch (error) {
      console.error('Failed to load executions:', error)
      throw error
    }
  }

  async function loadExecution(id: string) {
    try {
      const execution = await executionApi.getById(id)
      currentExecution.value = execution
    } catch (error) {
      console.error('Failed to load execution:', error)
      throw error
    }
  }

  async function startExecution(pipelineId: string, config?: any) {
    try {
      const execution = await executionApi.start(pipelineId, config)
      executions.value.unshift(execution)
      currentExecution.value = execution
      return execution
    } catch (error) {
      console.error('Failed to start execution:', error)
      throw error
    }
  }

  async function stopExecution(id: string) {
    try {
      await executionApi.stop(id)
      const execution = executions.value.find(e => e.id === id)
      if (execution) {
        execution.status = 'stopped'
      }
    } catch (error) {
      console.error('Failed to stop execution:', error)
      throw error
    }
  }

  function updateExecutionStatus(id: string, status: string) {
    const execution = executions.value.find(e => e.id === id)
    if (execution) {
      execution.status = status
    }
    if (currentExecution.value?.id === id) {
      currentExecution.value.status = status
    }
  }

  function addLog(log: ExecutionLog) {
    logs.value.push(log)

    // 限制日志数量
    if (logs.value.length > 1000) {
      logs.value.shift()
    }
  }

  function clearLogs() {
    logs.value = []
  }

  function updateMetrics(newMetrics: Metrics) {
    metrics.value = newMetrics
  }

  return {
    // State
    executions,
    currentExecution,
    logs,
    metrics,

    // Getters
    runningExecutions,
    failedExecutions,

    // Actions
    loadExecutions,
    loadExecution,
    startExecution,
    stopExecution,
    updateExecutionStatus,
    addLog,
    clearLogs,
    updateMetrics
  }
})
```

### 4.3 Store 持久化

```typescript
// stores/index.ts
import { createPinia } from 'pinia'
import piniaPluginPersistedstate from 'pinia-plugin-persistedstate'

const pinia = createPinia()
pinia.use(piniaPluginPersistedstate)

export default pinia

// 在 Store 中配置持久化
export const useUserStore = defineStore('user', () => {
  // ... store logic
}, {
  persist: {
    key: 'pipeline-builder-user',
    storage: localStorage,
    paths: ['currentUser', 'token', 'preferences']
  }
})
```

---

## 5. 路由设计

### 5.1 路由配置

```typescript
// router/routes.ts
import type { RouteRecordRaw } from 'vue-router'

export const routes: RouteRecordRaw[] = [
  {
    path: '/',
    component: () => import('@/layouts/DefaultLayout.vue'),
    redirect: '/pipelines',
    children: [
      {
        path: 'pipelines',
        name: 'PipelineList',
        component: () => import('@/views/pipeline/PipelineList.vue'),
        meta: {
          title: '管道列表',
          requiresAuth: true
        }
      },
      {
        path: 'pipelines/create',
        name: 'PipelineCreate',
        component: () => import('@/views/pipeline/PipelineCreate.vue'),
        meta: {
          title: '创建管道',
          requiresAuth: true,
          permission: 'pipeline:create'
        }
      },
      {
        path: 'pipelines/:id/edit',
        name: 'PipelineEditor',
        component: () => import('@/views/pipeline/PipelineEditor.vue'),
        props: true,
        meta: {
          title: '编辑管道',
          requiresAuth: true,
          permission: 'pipeline:edit'
        }
      },
      {
        path: 'pipelines/:id/view',
        name: 'PipelineView',
        component: () => import('@/views/pipeline/PipelineView.vue'),
        props: true,
        meta: {
          title: '查看管道',
          requiresAuth: true
        }
      },
      {
        path: 'executions',
        name: 'ExecutionList',
        component: () => import('@/views/execution/ExecutionList.vue'),
        meta: {
          title: '执行历史',
          requiresAuth: true
        }
      },
      {
        path: 'executions/:id',
        name: 'ExecutionDetail',
        component: () => import('@/views/execution/ExecutionDetail.vue'),
        props: true,
        meta: {
          title: '执行详情',
          requiresAuth: true
        }
      },
      {
        path: 'connections',
        name: 'ConnectionList',
        component: () => import('@/views/connection/ConnectionList.vue'),
        meta: {
          title: '数据源管理',
          requiresAuth: true,
          permission: 'connection:view'
        }
      },
      {
        path: 'lineage',
        name: 'LineageView',
        component: () => import('@/views/lineage/LineageView.vue'),
        meta: {
          title: '数据血缘',
          requiresAuth: true
        }
      },
      {
        path: 'settings',
        name: 'Settings',
        component: () => import('@/views/settings/UserSettings.vue'),
        meta: {
          title: '设置',
          requiresAuth: true
        }
      }
    ]
  },
  {
    path: '/auth',
    component: () => import('@/layouts/AuthLayout.vue'),
    children: [
      {
        path: 'login',
        name: 'Login',
        component: () => import('@/views/auth/Login.vue'),
        meta: {
          title: '登录'
        }
      }
    ]
  },
  {
    path: '/:pathMatch(.*)*',
    name: 'NotFound',
    component: () => import('@/views/error/404.vue')
  }
]
```

### 5.2 路由守卫

```typescript
// router/guards.ts
import type { Router } from 'vue-router'
import { useUserStore } from '@/stores/modules/user'
import { message } from 'ant-design-vue'

export function setupRouterGuards(router: Router) {
  // 认证守卫
  router.beforeEach(async (to, from, next) => {
    const userStore = useUserStore()

    // 设置页面标题
    document.title = to.meta.title
      ? `${to.meta.title} - Pipeline Builder`
      : 'Pipeline Builder'

    // 检查是否需要认证
    if (to.meta.requiresAuth && !userStore.isAuthenticated) {
      message.warning('请先登录')
      next({
        name: 'Login',
        query: { redirect: to.fullPath }
      })
      return
    }

    // 检查权限
    if (to.meta.permission && !userStore.hasPermission(to.meta.permission as string)) {
      message.error('没有权限访问该页面')
      next({ name: 'PipelineList' })
      return
    }

    next()
  })

  // 离开编辑器前确认
  router.beforeEach((to, from, next) => {
    if (from.name === 'PipelineEditor') {
      const pipelineStore = usePipelineStore()

      if (pipelineStore.isDirty) {
        if (confirm('有未保存的更改，确定要离开吗？')) {
          next()
        } else {
          next(false)
        }
        return
      }
    }

    next()
  })
}
```

---

## 6. 数据流设计

### 6.1 数据流向图

```
┌─────────────────────────────────────────────────────────────┐
│                         用户交互                            │
│                    (User Interaction)                       │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                         视图层                              │
│                    (View Components)                        │
│  • 触发 Store Actions                                       │
│  • 读取 Store State                                         │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                       状态管理层                            │
│                    (Pinia Stores)                           │
│  • 更新 State                                               │
│  • 调用 API                                                 │
│  • 触发副作用                                               │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                        API 层                               │
│                    (API Modules)                            │
│  • HTTP 请求                                                │
│  • WebSocket 通信                                           │
│  • 数据转换                                                 │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                        后端服务                             │
│                    (Backend API)                            │
└─────────────────────────────────────────────────────────────┘
```

### 6.2 典型数据流示例

**加载管道**：
```
用户点击编辑按钮
  ↓
PipelineList.vue 调用 router.push
  ↓
路由导航到 PipelineEditor.vue
  ↓
PipelineEditor.vue onMounted 钩子触发
  ↓
调用 pipelineStore.loadPipeline(id)
  ↓
pipelineStore 调用 pipelineApi.getById(id)
  ↓
API 发送 GET /api/v1/pipelines/:id 请求
  ↓
后端返回管道数据
  ↓
pipelineStore 更新 state (currentPipeline, nodes, edges)
  ↓
Vue 响应式系统触发视图更新
  ↓
GraphCanvas 组件渲染管道
```

**保存管道**：
```
用户修改节点配置
  ↓
ConfigPanel.vue emit('save', config)
  ↓
GraphCanvas.vue 调用 pipelineStore.updateNode(id, config)
  ↓
pipelineStore 更新 nodes state，标记 isDirty = true
  ↓
用户点击保存按钮
  ↓
调用 pipelineStore.savePipeline()
  ↓
pipelineStore 调用 pipelineApi.update(id, data)
  ↓
API 发送 PUT /api/v1/pipelines/:id 请求
  ↓
后端保存数据并返回
  ↓
pipelineStore 更新 currentPipeline，标记 isDirty = false
  ↓
显示保存成功消息
```

**实时执行监控**：
```
用户点击运行按钮
  ↓
ExecutionControl.vue 调用 executionStore.startExecution(pipelineId)
  ↓
executionStore 调用 executionApi.start(pipelineId)
  ↓
API 发送 POST /api/v1/pipelines/:id/execute 请求
  ↓
后端启动执行，返回 executionId
  ↓
前端建立 WebSocket 连接 /ws/executions/:id
  ↓
后端通过 WebSocket 推送实时更新：
  - status-update 事件 → executionStore.updateExecutionStatus()
  - log 事件 → executionStore.addLog()
  - metric 事件 → executionStore.updateMetrics()
  ↓
executionStore 更新 state
  ↓
Vue 响应式系统触发 ExecutionStatus 组件更新
  ↓
实时显示执行状态、日志、指标
```

---

**文档第二部分完成** ✓

接下来将编写：
- 第三部分：核心模块详细设计
- 第四部分：性能优化与部署方案
